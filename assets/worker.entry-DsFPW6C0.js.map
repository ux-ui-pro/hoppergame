{"version":3,"file":"worker.entry-DsFPW6C0.js","sources":["../src/config/spawn.ts","../src/game/worker/constants.ts","../src/config/visual.ts","../src/game/worker/state.ts","../src/config/speed.ts","../src/config/reaction.ts","../src/game/worker/logic.ts","../src/game/worker/assets.ts","../src/game/worker/render.ts","../src/game/worker.entry.ts"],"sourcesContent":["// Конфиг появления объектов сцены\r\n\r\nexport const SPAWN_CONFIG = {\r\n  obstacles: {\r\n    // Интервалы основного потока спавна (сек) — препятствия и сердца распределяются внутри\r\n    intervalMinSec: 1.0,\r\n    intervalMaxSec: 1.9,\r\n    // Доля скелетов среди негативных препятствий (остальное — blight)\r\n    skeletonInNegativeProb: 0.35,\r\n  },\r\n  heart: {\r\n    // Базовая вероятность появления сердца внутри основного потока\r\n    baseProb: 0.01,\r\n    // Ограничение «случайности» между сердцами (в количестве препятствий)\r\n    minGapObs: 9,\r\n    maxGapObs: 15,\r\n  },\r\n  coin: {\r\n    // Независимый поток спавна монет (сек)\r\n    intervalMinSec: 1.5,\r\n    intervalMaxSec: 3,\r\n  },\r\n  scaling: {\r\n    // До какого времени плавно усиливать сложность (сек)\r\n    targetSec: 180,\r\n    // Нижняя граница мультипликатора интервалов спавна (уменьшает интервалы, 0.6 = на 40% быстрее)\r\n    minMultiplier: 0.4,\r\n    // Минимально допустимый безопасный зазор между препятствиями (сек) — из физики прыжка\r\n    minSafeGapSec: 0.7,\r\n    // Вклад монет: при 100 монетах — до 30% ускорения интервалов\r\n    coinFullScale: 100,\r\n    coinFactor: 0.25,\r\n    // Вклад «стрику без ударов»: при 30 сек — до 20% ускорения\r\n    streakFullSec: 30,\r\n    streakFactor: 0.125,\r\n    // Анти‑фрустрация после удара/при низких жизнях\r\n    relax: {\r\n      whenLifeLE: 1,\r\n      recentHitSecs: 5,\r\n      relaxMultiplier: 1.15,\r\n    },\r\n    // «Окна отдыха» при максимальной плотности\r\n    rest: {\r\n      whenMultiplierLE: 0.7,   // раньше включаем окна (чуть менее экстремальная сложность)\r\n      probability: 0.4,        // чаще вставляем окно отдыха\r\n      gapMultiplier: 4.0,      // длиннее окно: 4 × minSafeGapSec\r\n      cooldownSec: 5,          // немного чаще, короче кулдаун\r\n    },\r\n  },\r\n} as const;\r\n","import { GAME_HEIGHT, groundY, speedX, gravityAccel, jumpVelocity } from '@/config/physics';\r\nexport { GAME_HEIGHT, groundY, speedX, gravityAccel, jumpVelocity };\r\n\r\n// (Ground mechanics removed)\r\n\r\n// Интервал спавна препятствий (сек): берём из конфига\r\nimport { SPAWN_CONFIG } from '@/config/spawn';\r\nexport const SPAWN_INTERVAL_MIN_SEC = SPAWN_CONFIG.obstacles.intervalMinSec;\r\nexport const SPAWN_INTERVAL_MAX_SEC = SPAWN_CONFIG.obstacles.intervalMaxSec;\r\n\r\n// Ограничение «случайности» появления сердца\r\nexport const HEART_BASE_PROB = SPAWN_CONFIG.heart.baseProb;\r\nexport const HEART_MIN_GAP_OBS = SPAWN_CONFIG.heart.minGapObs;\r\nexport const HEART_MAX_GAP_OBS = SPAWN_CONFIG.heart.maxGapObs;\r\n// Доля скелетов среди «негативных» препятствий (остальное — blight)\r\nexport const SKELETON_IN_NEGATIVE_PROB = SPAWN_CONFIG.obstacles.skeletonInNegativeProb;\r\n\r\n// Coin: независимый спавн (сек)\r\nexport const COIN_SPAWN_INTERVAL_MIN_SEC = SPAWN_CONFIG.coin.intervalMinSec;\r\nexport const COIN_SPAWN_INTERVAL_MAX_SEC = SPAWN_CONFIG.coin.intervalMaxSec;\r\n// Render caps (device-px)\r\nexport const MAX_W_PX = 3072;\r\nexport const MAX_H_PX = 3072;\r\n\r\n\r\n","import type { Entity } from '@/types/game';\r\n\r\nexport interface VisualCfg {\r\n  hitboxW: number;      // CSS px\r\n  hitboxH: number;      // CSS px\r\n  visualHeight: number; // CSS px\r\n  offsetX: number;      // CSS px, +вправо\r\n  offsetY: number;      // CSS px, +вверх (к нижней грани хитбокса)\r\n}\r\n\r\nexport const playerConfig: VisualCfg = {\r\n  hitboxW: 20,\r\n  hitboxH: 60,\r\n  visualHeight: 80,\r\n  offsetX: 5,\r\n  offsetY: 0,\r\n};\r\n\r\ntype Kind = Entity['kind'];\r\n\r\nexport const entitiesConfig: Record<Kind, VisualCfg> = {\r\n  blight: {\r\n    hitboxW: 30,\r\n    hitboxH: 40,\r\n    visualHeight: 80,\r\n    offsetX: 4,\r\n    offsetY: 0,\r\n  },\r\n  skeleton: {\r\n    hitboxW: 20,\r\n    hitboxH: 60,\r\n    visualHeight: 80,\r\n    offsetX: -7,\r\n    offsetY: 0,\r\n  },\r\n  heart: {\r\n    hitboxW: 16,\r\n    hitboxH: 16,\r\n    visualHeight: 80,\r\n    offsetX: 0,\r\n    offsetY: 28,\r\n  },\r\n  coin: {\r\n    hitboxW: 24,\r\n    hitboxH: 24,\r\n    visualHeight: 80,\r\n    offsetX: 0,\r\n    offsetY: 30,\r\n  },\r\n};\r\n\r\n// На сколько CSS‑px линия земли (top) прижата вверх от нижней границы холста.\r\n// Используется рендером для вычисления вертикального смещения сцены.\r\nexport const GROUND_BOTTOM_MARGIN_CSS = 160;\r\n\r\n\r\n","import type { Player, Entity } from '@/types/game';\r\nimport {\r\n  GAME_HEIGHT,\r\n  groundY,\r\n  MAX_W_PX,\r\n  MAX_H_PX,\r\n  gravityAccel,\r\n  jumpVelocity,\r\n  SPAWN_INTERVAL_MIN_SEC,\r\n  SPAWN_INTERVAL_MAX_SEC,\r\n} from './constants';\r\nimport { playerConfig } from '@/config/visual';\r\n\r\nexport interface AtlasFrameRect { x: number; y: number; w: number; h: number; }\r\nexport interface AtlasFrame {\r\n  frame: AtlasFrameRect;\r\n  rotated: boolean;\r\n  trimmed: boolean;\r\n  spriteSourceSize: AtlasFrameRect;\r\n  sourceSize: { w: number; h: number };\r\n  pivot: { x: number; y: number };\r\n}\r\nexport interface PlayerAtlas {\r\n  meta: {\r\n    image: string;\r\n    size: { w: number; h: number };\r\n    scale: number | string;\r\n    frameWidth?: number;\r\n    frameHeight?: number;\r\n  };\r\n  frames: Record<string, AtlasFrame>;\r\n  animations?: Record<string, string[]>;\r\n}\r\n\r\nexport interface GameState {\r\n  ctx: OffscreenCanvasRenderingContext2D | null;\r\n  canvas: OffscreenCanvas | null;\r\n\r\n  cssW: number;\r\n  cssH: number;\r\n  scale: number;\r\n\r\n  // transparency\r\n  transparentBg: boolean;\r\n\r\n  // readiness handshake\r\n  ready: boolean;\r\n  expectResize: boolean;\r\n  readyTimer: number | null;\r\n\r\n  // world\r\n  coinCount: number;\r\n  lifeCount: number;\r\n  uiDirty: boolean;\r\n  uiElapsedMs: number;\r\n  uiIntervalMs: number;\r\n  // difficulty scaling\r\n  elapsedSec: number;\r\n  noHitSec: number;\r\n  recentHitCooldownSec: number;\r\n  restCooldownSec: number;\r\n\r\n  // скорость прокрутки\r\n  speedMultiplier?: number;\r\n  scrollSpeedX?: number;\r\n  speedNotifyCooldownMs?: number;\r\n\r\n  player: Player;\r\n  entities: Entity[];\r\n  spawnTimerSec: number;\r\n  nextSpawnSec: number;\r\n  pendingJump: boolean;\r\n  // расширенный ввод прыжка\r\n  jumpQueuedMs?: number;\r\n  coyoteRemainingMs?: number;\r\n  hasUsedDoubleJump?: boolean;\r\n  // сколько препятствий прошло с момента последнего появления сердца\r\n  sinceLastHeartCount: number;\r\n  // coin independent spawner\r\n  coinSpawnTimerSec: number;\r\n  coinNextSpawnSec: number;\r\n\r\n  // visuals\r\n  skyColor: string;\r\n  // debug\r\n  debugDrawHitboxes?: boolean;\r\n\r\n  // player sprite/atlas\r\n  playerSpriteUrl: string;\r\n  playerAtlasUrl: string;\r\n  playerSprite: ImageBitmap | null;\r\n  playerAtlas: PlayerAtlas | null;\r\n  playerSpriteLoading: boolean;\r\n  playerRunFrames: string[];\r\n  playerJumpFrames: string[];\r\n  playerHitFrames: string[];\r\n  playerRewardFrames: string[];\r\n  // death animation frames\r\n  playerDyingFrames: string[];\r\n  blightFrames: string[];\r\n  heartFrames: string[];\r\n  coinFrameName: string | null;\r\n  coinFrames: string[];\r\n  blightAnimElapsedMs: number;\r\n  blightAnimFrameIndex: number;\r\n  skeletonFrames: string[];\r\n  heartAnimElapsedMs: number;\r\n  heartAnimFrameIndex: number;\r\n  coinAnimElapsedMs: number;\r\n  coinAnimFrameIndex: number;\r\n  skeletonAnimElapsedMs: number;\r\n  skeletonAnimFrameIndex: number;\r\n  playerAnimFps: number;\r\n  playerAnimFrameMs: number;\r\n  playerAnimElapsedMs: number;\r\n  playerAnimFrameIndex: number;\r\n  // run phase preservation across jump\r\n  playerRunStartIndexAtJump: number;\r\n  playerRunPhaseMsDuringJump: number;\r\n  // jump timing (for time-based frame selection)\r\n  playerJumpElapsedMs: number;\r\n  playerJumpTotalMs: number;\r\n  // hit one-shot state\r\n  playerHitPlaying: boolean;\r\n  playerHitElapsedMs: number;\r\n  playerHitFrameIndex: number;\r\n  // reward one-shot state\r\n  playerRewardPlaying: boolean;\r\n  playerRewardElapsedMs: number;\r\n  playerRewardFrameIndex: number;\r\n  // dying state\r\n  isDying: boolean;\r\n  dyingElapsedMs: number;\r\n  dyingDurationMs: number;\r\n  gameOverSent: boolean;\r\n  // dying animation state\r\n  playerDyingPlaying: boolean;\r\n  playerDyingElapsedMs: number;\r\n  playerDyingFrameIndex: number;\r\n\r\n  // previous-step snapshot (for render interpolation)\r\n  prevPlayerY: number;\r\n\r\n}\r\n\r\nconst playerSpriteUrlObj = new URL('../../assets/images/webp/runner-sprite-sheet.webp', import.meta.url);\r\nconst playerAtlasUrlObj = new URL('../../assets/images/webp/runner-sprite-sheet.json', import.meta.url);\r\n\r\nexport const state: GameState = {\r\n  ctx: null,\r\n  canvas: null,\r\n\r\n  cssW: 0,\r\n  cssH: 0,\r\n  scale: 1,\r\n\r\n  transparentBg: false,\r\n\r\n  ready: false,\r\n  expectResize: false,\r\n  readyTimer: null,\r\n\r\n  coinCount: 0,\r\n  lifeCount: 3,\r\n  uiDirty: true,\r\n  uiElapsedMs: 0,\r\n  uiIntervalMs: 120,\r\n  elapsedSec: 0,\r\n  noHitSec: 0,\r\n  recentHitCooldownSec: 0,\r\n  restCooldownSec: 0,\r\n  speedMultiplier: 1,\r\n  scrollSpeedX: 0,\r\n  speedNotifyCooldownMs: 0,\r\n\r\n  player: {\r\n    x: 0,\r\n    y: groundY - playerConfig.hitboxH,\r\n    width: playerConfig.hitboxW,\r\n    height: playerConfig.hitboxH,\r\n    vy: 0,\r\n    isJumping: false,\r\n  },\r\n  entities: [],\r\n  spawnTimerSec: 0,\r\n  sinceLastHeartCount: 0,\r\n  nextSpawnSec: SPAWN_INTERVAL_MIN_SEC + Math.random() * (SPAWN_INTERVAL_MAX_SEC - SPAWN_INTERVAL_MIN_SEC),\r\n  pendingJump: false,\r\n  jumpQueuedMs: 0,\r\n  coyoteRemainingMs: 0,\r\n  hasUsedDoubleJump: false,\r\n  coinSpawnTimerSec: 0,\r\n  coinNextSpawnSec: 0, // будет установлено при первом тике по COIN_SPAWN_INTERVAL_*\r\n\r\n  skyColor: '#e0f7fa',\r\n  debugDrawHitboxes: false,\r\n\r\n  playerSpriteUrl: playerSpriteUrlObj.toString(),\r\n  playerAtlasUrl: playerAtlasUrlObj.toString(),\r\n  playerSprite: null,\r\n  playerAtlas: null,\r\n  playerSpriteLoading: false,\r\n  playerRunFrames: [],\r\n  playerJumpFrames: [],\r\n  playerHitFrames: [],\r\n  playerRewardFrames: [],\r\n  playerDyingFrames: [],\r\n  blightFrames: [],\r\n  heartFrames: [],\r\n  coinFrameName: null,\r\n  coinFrames: [],\r\n  blightAnimElapsedMs: 0,\r\n  blightAnimFrameIndex: 0,\r\n  skeletonFrames: [],\r\n  heartAnimElapsedMs: 0,\r\n  heartAnimFrameIndex: 0,\r\n  coinAnimElapsedMs: 0,\r\n  coinAnimFrameIndex: 0,\r\n  skeletonAnimElapsedMs: 0,\r\n  skeletonAnimFrameIndex: 0,\r\n  playerAnimFps: 12,\r\n  playerAnimFrameMs: 1000 / 12,\r\n  playerAnimElapsedMs: 0,\r\n  playerAnimFrameIndex: 0,\r\n  playerRunStartIndexAtJump: 0,\r\n  playerRunPhaseMsDuringJump: 0,\r\n  playerJumpElapsedMs: 0,\r\n  playerJumpTotalMs: (2 * Math.abs(jumpVelocity) / Math.abs(gravityAccel)) * 1000,\r\n  playerHitPlaying: false,\r\n  playerHitElapsedMs: 0,\r\n  playerHitFrameIndex: 0,\r\n  playerRewardPlaying: false,\r\n  playerRewardElapsedMs: 0,\r\n  playerRewardFrameIndex: 0,\r\n  isDying: false,\r\n  dyingElapsedMs: 0,\r\n  dyingDurationMs: 2000,\r\n  gameOverSent: false,\r\n  playerDyingPlaying: false,\r\n  playerDyingElapsedMs: 0,\r\n  playerDyingFrameIndex: 0,\r\n\r\n  prevPlayerY: groundY - playerConfig.hitboxH,\r\n};\r\n\r\nexport function applyCanvasSize(s: GameState, newCssW: number, newCssH: number, dpr: number): void {\r\n  s.cssW = Math.max(1, Math.floor(newCssW));\r\n  s.cssH = Math.max(1, Math.floor(newCssH));\r\n\r\n  // Адаптивный кламп DPR: учитываем капы буфера, размер контейнера и производительность\r\n  const rawDpr = Math.max(dpr || 1, 1);\r\n  const areaCss = Math.max(1, s.cssW * s.cssH);\r\n  const maxAreaPx = MAX_W_PX * MAX_H_PX;\r\n  const dprByCaps = Math.max(1, Math.sqrt(maxAreaPx / areaCss));\r\n  const perfCap = (s.cssW >= 1024 || s.cssH >= 1024) ? 2 : 3;\r\n  const quantize = (x: number) => Math.max(1, Math.round(x / 0.25) * 0.25);\r\n  const dprClamped = quantize(Math.min(rawDpr, dprByCaps, perfCap));\r\n\r\n  const sW = MAX_W_PX / s.cssW;\r\n  const sH = MAX_H_PX / s.cssH;\r\n\r\n  let bound: 'dpr' | 'w' | 'h' = 'dpr';\r\n  let uniform = dprClamped;\r\n  if (sW < uniform) { uniform = sW; bound = 'w'; }\r\n  if (sH < uniform) { uniform = sH; bound = 'h'; }\r\n  s.scale = Math.max(1 / 8, uniform);\r\n\r\n  let targetWpx = 0;\r\n  let targetHpx = 0;\r\n  if (bound === 'h') {\r\n    targetHpx = Math.max(1, Math.floor(s.cssH * s.scale));\r\n    targetWpx = Math.max(1, Math.round(targetHpx * (s.cssW / s.cssH)));\r\n  } else if (bound === 'w') {\r\n    targetWpx = Math.max(1, Math.floor(s.cssW * s.scale));\r\n    targetHpx = Math.max(1, Math.round(targetWpx * (s.cssH / s.cssW)));\r\n  } else {\r\n    targetWpx = Math.max(1, Math.round(s.cssW * s.scale));\r\n    targetHpx = Math.max(1, Math.round(s.cssH * s.scale));\r\n  }\r\n\r\n  if (!s.canvas || !s.ctx) return;\r\n\r\n  if (s.canvas.width !== targetWpx) s.canvas.width = targetWpx;\r\n  if (s.canvas.height !== targetHpx) s.canvas.height = targetHpx;\r\n\r\n\r\n\r\n  s.player.x = s.cssW * 0.14;\r\n}\r\n\r\nexport { GAME_HEIGHT, groundY };\r\n\r\n\r\n","// Конфиг прогрессии скорости игры (мультипликатор к базовой speedX)\r\nexport const SPEED_CONFIG = {\r\n  // Начальный множитель (1 = базовая скорость)\r\n  startMultiplier: 1,\r\n  // Верхняя граница множителя\r\n  maxMultiplier: 2.2,\r\n  // Время разгона до капа (сек)\r\n  accelDurationSec: 90,\r\n  // Частота отправки апдейтов скорости наружу (мс)\r\n  notifyIntervalMs: 150,\r\n} as const;\r\n\r\nexport function computeSpeedMultiplier(elapsedSec: number): number {\r\n  const t = Math.max(0, Math.min(1, elapsedSec / SPEED_CONFIG.accelDurationSec));\r\n  // easeInOutQuad\r\n  const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;\r\n  const span = SPEED_CONFIG.maxMultiplier - SPEED_CONFIG.startMultiplier;\r\n  return Math.max(\r\n    SPEED_CONFIG.startMultiplier,\r\n    Math.min(SPEED_CONFIG.maxMultiplier, SPEED_CONFIG.startMultiplier + ease * span)\r\n  );\r\n}\r\n\r\n\r\n","// Эвристика времени реакции игрока в секундах как функция времени забега.\r\n// Линейно/плавно уменьшаем от стартового к минимальному значению за заданный период.\r\nexport const REACTION_CONFIG = {\r\n  startSec: 0.65,\r\n  minSec: 0.35,\r\n  durationSec: 90,\r\n} as const;\r\n\r\nexport function computeReactionTimeSec(elapsedSec: number): number {\r\n  const t = Math.max(0, Math.min(1, elapsedSec / REACTION_CONFIG.durationSec));\r\n  // easeInOutQuad\r\n  const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;\r\n  const span = Math.max(0, REACTION_CONFIG.startSec - REACTION_CONFIG.minSec);\r\n  return Math.max(REACTION_CONFIG.minSec, REACTION_CONFIG.startSec - ease * span);\r\n}\r\n\r\n\r\n","import type { GameState } from './state';\r\nimport type { WorkerOutMessage } from '@/types/workerMessages';\r\nimport { groundY, speedX, gravityAccel, jumpVelocity, SPAWN_INTERVAL_MIN_SEC, SPAWN_INTERVAL_MAX_SEC, HEART_BASE_PROB, HEART_MIN_GAP_OBS, HEART_MAX_GAP_OBS, COIN_SPAWN_INTERVAL_MIN_SEC, COIN_SPAWN_INTERVAL_MAX_SEC, SKELETON_IN_NEGATIVE_PROB } from './constants';\r\nimport { SPAWN_CONFIG } from '@/config/spawn';\r\nimport { entitiesConfig } from '@/config/visual';\r\nimport { computeSpeedMultiplier, SPEED_CONFIG } from '@/config/speed';\r\nimport { computeReactionTimeSec } from '@/config/reaction';\r\n\r\nexport function update(s: GameState, dtSec: number): void {\r\n  if (!s.ctx) return;\r\n\r\n  // capture previous-state snapshot for interpolation (last applied step wins)\r\n  s.prevPlayerY = s.player.y;\r\n\r\n  // difficulty timers\r\n  s.elapsedSec += dtSec;\r\n  s.noHitSec += dtSec;\r\n  if (s.recentHitCooldownSec > 0) {\r\n    s.recentHitCooldownSec = Math.max(0, s.recentHitCooldownSec - dtSec);\r\n  }\r\n  if (s.restCooldownSec > 0) {\r\n    s.restCooldownSec = Math.max(0, s.restCooldownSec - dtSec);\r\n  }\r\n\r\n  // скорость игры: мультипликатор и текущая прокрутка по X\r\n  const mult = computeSpeedMultiplier(s.elapsedSec);\r\n  s.speedMultiplier = mult;\r\n  s.scrollSpeedX = speedX * mult;\r\n  // нотификация о скорости не чаще заданного интервала\r\n  s.speedNotifyCooldownMs = Math.max(0, (s.speedNotifyCooldownMs || 0) - dtSec * 1000);\r\n  if (s.speedNotifyCooldownMs <= 0) {\r\n    try { postMessage({ type: 'speed', m: mult } as WorkerOutMessage); } catch {}\r\n    s.speedNotifyCooldownMs = SPEED_CONFIG.notifyIntervalMs;\r\n  }\r\n\r\n  // Окна прыжка\r\n  const JUMP_BUFFER_MS = 120;\r\n  const COYOTE_WINDOW_MS = 100;\r\n  const MIN_DOUBLE_JUMP_DELAY_MS = 150;\r\n  // перенос pending → буфер\r\n  if (!s.isDying && s.pendingJump) {\r\n    s.pendingJump = false;\r\n    s.jumpQueuedMs = Math.max(s.jumpQueuedMs || 0, JUMP_BUFFER_MS);\r\n  }\r\n  // тик таймеров окна прыжка\r\n  if (!s.isDying) {\r\n    s.jumpQueuedMs = Math.max(0, (s.jumpQueuedMs || 0) - dtSec * 1000);\r\n    s.coyoteRemainingMs = Math.max(0, (s.coyoteRemainingMs || 0) - dtSec * 1000);\r\n  }\r\n\r\n  if (!s.isDying) {\r\n    // первичный или двойной прыжок по буферу/койоту\r\n    const canGroundJump = (!s.player.isJumping) || (s.coyoteRemainingMs || 0) > 0;\r\n    const canDoubleJump = s.player.isJumping && !s.hasUsedDoubleJump && (s.playerJumpElapsedMs || 0) >= MIN_DOUBLE_JUMP_DELAY_MS;\r\n    if ((s.jumpQueuedMs || 0) > 0 && (canGroundJump || canDoubleJump)) {\r\n      s.jumpQueuedMs = 0;\r\n      // если на земле или в койоте — первый прыжок, иначе двойной\r\n      const firstJump = canGroundJump;\r\n      s.player.isJumping = true;\r\n      s.player.vy = -jumpVelocity;\r\n      if (firstJump) {\r\n        s.hasUsedDoubleJump = false;\r\n        s.coyoteRemainingMs = 0;\r\n        // уведомим главный поток о старте прыжка (для SFX)\r\n        try { postMessage({ type: 'sfx', s: 'jump' } as WorkerOutMessage); } catch {}\r\n        // зафиксировать фазу бега и обнулить накопление на период прыжка\r\n        s.playerRunStartIndexAtJump = s.playerAnimFrameIndex;\r\n        s.playerRunPhaseMsDuringJump = 0;\r\n        s.playerJumpElapsedMs = 0;\r\n      } else {\r\n        s.hasUsedDoubleJump = true;\r\n        try { postMessage({ type: 'sfx', s: 'jump' } as WorkerOutMessage); } catch {}\r\n      }\r\n    }\r\n  } else {\r\n    // во время смерти — фиксируем игрока на земле и гасим прыжок\r\n    s.pendingJump = false;\r\n    s.player.isJumping = false;\r\n    s.player.vy = 0;\r\n    s.player.y = groundY - s.player.height;\r\n  }\r\n\r\n  if (!s.isDying && s.player.isJumping) {\r\n    s.player.vy += gravityAccel * dtSec;\r\n    s.player.y += s.player.vy * dtSec;\r\n    // «немой» прогресс бега во время прыжка\r\n    s.playerRunPhaseMsDuringJump += dtSec * 1000;\r\n    s.playerJumpElapsedMs = Math.min(s.playerJumpTotalMs, s.playerJumpElapsedMs + dtSec * 1000);\r\n    if (s.player.y >= groundY - s.player.height) {\r\n      s.player.y = groundY - s.player.height;\r\n      s.player.vy = 0;\r\n      s.player.isJumping = false;\r\n      s.playerJumpElapsedMs = s.playerJumpTotalMs;\r\n      s.hasUsedDoubleJump = false;\r\n      s.coyoteRemainingMs = COYOTE_WINDOW_MS;\r\n      // старт бега с фиксированного кадра run_0\r\n      if (s.playerRunFrames.length > 0) {\r\n        s.playerAnimFrameIndex = 0;\r\n        s.playerAnimElapsedMs = 0;\r\n      }\r\n      s.playerRunPhaseMsDuringJump = 0;\r\n    }\r\n  }\r\n\r\n  // Player animation update:\r\n  // - if dying, advance dying frames (one-shot)\r\n  // - else reward one-shot → hit one-shot → run cycle; in jump кадры выбираем в рендере\r\n  if (s.playerSprite && s.playerAtlas) {\r\n    if (s.isDying && s.playerDyingFrames && s.playerDyingFrames.length > 0) {\r\n      s.playerDyingElapsedMs += dtSec * 1000;\r\n      while (s.playerDyingElapsedMs >= s.playerAnimFrameMs) {\r\n        s.playerDyingElapsedMs -= s.playerAnimFrameMs;\r\n        if (s.playerDyingFrameIndex + 1 < s.playerDyingFrames.length) {\r\n          s.playerDyingFrameIndex += 1;\r\n        } else {\r\n          s.playerDyingPlaying = false;\r\n          s.playerDyingFrameIndex = s.playerDyingFrames.length - 1;\r\n          break;\r\n        }\r\n      }\r\n    } else if (s.playerRewardPlaying && s.playerRewardFrames.length > 0) {\r\n      s.playerRewardElapsedMs += dtSec * 1000;\r\n      while (s.playerRewardElapsedMs >= s.playerAnimFrameMs) {\r\n        s.playerRewardElapsedMs -= s.playerAnimFrameMs;\r\n        if (s.playerRewardFrameIndex + 1 < s.playerRewardFrames.length) {\r\n          s.playerRewardFrameIndex += 1;\r\n        } else {\r\n          s.playerRewardPlaying = false;\r\n          s.playerRewardFrameIndex = s.playerRewardFrames.length - 1;\r\n          break;\r\n        }\r\n      }\r\n    } else if (s.playerHitPlaying && s.playerHitFrames.length > 0) {\r\n      s.playerHitElapsedMs += dtSec * 1000;\r\n      while (s.playerHitElapsedMs >= s.playerAnimFrameMs) {\r\n        s.playerHitElapsedMs -= s.playerAnimFrameMs;\r\n        if (s.playerHitFrameIndex + 1 < s.playerHitFrames.length) {\r\n          s.playerHitFrameIndex += 1;\r\n        } else {\r\n          s.playerHitPlaying = false;\r\n          s.playerHitFrameIndex = s.playerHitFrames.length - 1;\r\n          break;\r\n        }\r\n      }\r\n    } else if (s.playerRunFrames.length > 0) {\r\n      if (s.player.isJumping) {\r\n        s.playerAnimFrameIndex = 0;\r\n        s.playerAnimElapsedMs = 0;\r\n      } else {\r\n        s.playerAnimElapsedMs += dtSec * 1000;\r\n        while (s.playerAnimElapsedMs >= s.playerAnimFrameMs) {\r\n          s.playerAnimElapsedMs -= s.playerAnimFrameMs;\r\n          s.playerAnimFrameIndex = (s.playerAnimFrameIndex + 1) % s.playerRunFrames.length;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Coin animation tick (global index for all coins) — замораживаем во время смерти\r\n  if (!s.isDying && s.coinFrames.length > 0) {\r\n    s.coinAnimElapsedMs += dtSec * 1000;\r\n    while (s.coinAnimElapsedMs >= s.playerAnimFrameMs) {\r\n      s.coinAnimElapsedMs -= s.playerAnimFrameMs;\r\n      s.coinAnimFrameIndex = (s.coinAnimFrameIndex + 1) % s.coinFrames.length;\r\n    }\r\n  }\r\n  // Heart animation tick (global index for all hearts)\r\n  if (!s.isDying && s.heartFrames.length > 0) {\r\n    s.heartAnimElapsedMs += dtSec * 1000;\r\n    while (s.heartAnimElapsedMs >= s.playerAnimFrameMs) {\r\n      s.heartAnimElapsedMs -= s.playerAnimFrameMs;\r\n      s.heartAnimFrameIndex = (s.heartAnimFrameIndex + 1) % s.heartFrames.length;\r\n    }\r\n  }\r\n  // Skeleton animation tick (global index for all skeletons)\r\n  if (!s.isDying && s.skeletonFrames.length > 0) {\r\n    s.skeletonAnimElapsedMs += dtSec * 1000;\r\n    while (s.skeletonAnimElapsedMs >= s.playerAnimFrameMs) {\r\n      s.skeletonAnimElapsedMs -= s.playerAnimFrameMs;\r\n      s.skeletonAnimFrameIndex = (s.skeletonAnimFrameIndex + 1) % s.skeletonFrames.length;\r\n    }\r\n  }\r\n  // Blight animation tick (global index for all blights)\r\n  if (!s.isDying && (s as any).blightFrames && (s as any).blightFrames.length > 0) {\r\n    s.blightAnimElapsedMs += dtSec * 1000;\r\n    while (s.blightAnimElapsedMs >= s.playerAnimFrameMs) {\r\n      s.blightAnimElapsedMs -= s.playerAnimFrameMs;\r\n      s.blightAnimFrameIndex = (s.blightAnimFrameIndex + 1) % s.blightFrames.length;\r\n    }\r\n  }\r\n\r\n  if (!s.isDying) s.spawnTimerSec += dtSec;\r\n  if (!s.isDying && s.spawnTimerSec >= s.nextSpawnSec) {\r\n    // переходим на «статичную» плотность без скейлинга\r\n    // ограниченный рандом: пороги появления сердца\r\n    const roll = Math.random();\r\n    let bucket: 'negative' | 'collectible';\r\n    if (s.sinceLastHeartCount < HEART_MIN_GAP_OBS) {\r\n      bucket = 'negative';\r\n    } else if (s.sinceLastHeartCount >= HEART_MAX_GAP_OBS) {\r\n      bucket = 'collectible';\r\n    } else {\r\n      bucket = roll < HEART_BASE_PROB ? 'collectible' : 'negative';\r\n    }\r\n\r\n    if (bucket === 'negative' || s.lifeCount >= 3) {\r\n      // динамическая доля скелетов: растёт по времени\r\n      const tNorm = Math.max(0, Math.min(1, s.elapsedSec / SPAWN_CONFIG.scaling.targetSec));\r\n      const skeletonProb = Math.max(0, Math.min(0.95, SKELETON_IN_NEGATIVE_PROB + 0.35 * tNorm));\r\n      const isSkeleton = Math.random() < skeletonProb;\r\n\r\n      // Глобальное правило честного зазора по времени полёта прыжка\r\n      const airSec = Math.max(0.1, (s.playerJumpTotalMs || 0) / 1000);\r\n      const reactSec = computeReactionTimeSec(s.elapsedSec);\r\n      const minGapSec = Math.max(SPAWN_CONFIG.scaling.minSafeGapSec, 0.6 * airSec, reactSec);\r\n      const minTimeGapCss = Math.max(20, Math.round((s.scrollSpeedX || speedX) * minGapSec));\r\n      // найдём последнее негативное препятствие\r\n      let lastNeg: typeof s.entities[number] | null = null;\r\n      for (let j = s.entities.length - 1; j >= 0; j--) {\r\n        const e = s.entities[j]!;\r\n        if (e.kind === 'blight' || e.kind === 'skeleton') { lastNeg = e; break; }\r\n      }\r\n      const minHorzGapCss = Math.max(minTimeGapCss, (lastNeg?.width ?? 0) + 12);\r\n      const spawnX = Math.max(s.cssW, (lastNeg ? lastNeg.x + minHorzGapCss : s.cssW));\r\n\r\n      if (isSkeleton) {\r\n        const cfg = entitiesConfig.skeleton;\r\n        s.entities.push({ x: spawnX, y: groundY - cfg.hitboxH, width: cfg.hitboxW, height: cfg.hitboxH, kind: 'skeleton' });\r\n      } else {\r\n        const cfg = entitiesConfig.blight;\r\n        s.entities.push({ x: spawnX, y: groundY - cfg.hitboxH, width: cfg.hitboxW, height: cfg.hitboxH, kind: 'blight' });\r\n      }\r\n      s.sinceLastHeartCount += 1;\r\n\r\n      // Умеренный шанс «двойного» спавна без агрессивного уплотнения\r\n      if (Math.random() < 0.1) {\r\n        // последняя вставленная — негативное препятствие; используем динамический безопасный зазор\r\n        const last = s.entities[s.entities.length - 1];\r\n        const airSec2 = Math.max(0.1, (s.playerJumpTotalMs || 0) / 1000);\r\n        const reactSec2 = computeReactionTimeSec(s.elapsedSec);\r\n        const minGapSec2 = Math.max(SPAWN_CONFIG.scaling.minSafeGapSec, 0.6 * airSec2, reactSec2) * 1.2;\r\n        const minTimeGapCss2 = Math.max(20, Math.round((s.scrollSpeedX || speedX) * minGapSec2));\r\n        const minHorzGapCss2 = Math.max(minTimeGapCss2, (last?.width ?? 0) + 16);\r\n        const spawnX2 = (last ? last.x : s.cssW) + minHorzGapCss2;\r\n\r\n        // старайтесь не дублировать тип подряд: если рандом совпал — инвертируем\r\n        let secondIsSkeleton = Math.random() < skeletonProb;\r\n        if (last && last.kind === 'skeleton' && secondIsSkeleton) secondIsSkeleton = false;\r\n        if (last && last.kind === 'blight' && !secondIsSkeleton) secondIsSkeleton = true;\r\n\r\n        if (secondIsSkeleton) {\r\n          const cfg = entitiesConfig.skeleton;\r\n          s.entities.push({ x: spawnX2, y: groundY - cfg.hitboxH, width: cfg.hitboxW, height: cfg.hitboxH, kind: 'skeleton' });\r\n        } else {\r\n          const cfg = entitiesConfig.blight;\r\n          s.entities.push({ x: spawnX2, y: groundY - cfg.hitboxH, width: cfg.hitboxW, height: cfg.hitboxH, kind: 'blight' });\r\n        }\r\n      }\r\n    } else {\r\n      // collectible здесь — сердце: размещаем под двойной прыжок\r\n      const cfg = entitiesConfig.heart;\r\n      const heartH = cfg.hitboxH;\r\n      const apexSingle = (jumpVelocity * jumpVelocity) / (2 * Math.abs(gravityAccel));\r\n      const apexDouble = 2 * apexSingle;\r\n      const bottomY2 = Math.max(0, groundY - apexDouble);\r\n      const y = Math.max(0, bottomY2 - heartH);\r\n      s.entities.push({ x: s.cssW, y, width: cfg.hitboxW, height: heartH, kind: 'heart' });\r\n      s.sinceLastHeartCount = 0;\r\n    }\r\n    s.spawnTimerSec = 0;\r\n    const baseNext = SPAWN_INTERVAL_MIN_SEC + Math.random() * Math.max(0, (SPAWN_INTERVAL_MAX_SEC - SPAWN_INTERVAL_MIN_SEC));\r\n    s.nextSpawnSec = Math.max(SPAWN_CONFIG.scaling.minSafeGapSec, baseNext);\r\n  }\r\n\r\n  // Независимый спавн монет (может совпадать по X/Y с другими объектами) — на паузе во время смерти\r\n  if (!s.isDying) s.coinSpawnTimerSec += dtSec;\r\n  if (!s.isDying && s.coinNextSpawnSec <= 0) {\r\n    s.coinNextSpawnSec = COIN_SPAWN_INTERVAL_MIN_SEC + Math.random() * (COIN_SPAWN_INTERVAL_MAX_SEC - COIN_SPAWN_INTERVAL_MIN_SEC);\r\n  }\r\n  if (!s.isDying && s.coinSpawnTimerSec >= s.coinNextSpawnSec) {\r\n    const cfg = entitiesConfig.coin;\r\n    const coinH = cfg.hitboxH;\r\n    const apex = (jumpVelocity * jumpVelocity) / (2 * Math.abs(gravityAccel)); // высота вершины прыжка\r\n    const bottomY = Math.max(0, groundY - apex);\r\n    const y = Math.max(0, bottomY - coinH);\r\n    s.entities.push({ x: s.cssW, y, width: cfg.hitboxW, height: coinH, kind: 'coin' });\r\n    s.coinSpawnTimerSec = 0;\r\n    s.coinNextSpawnSec = COIN_SPAWN_INTERVAL_MIN_SEC + Math.random() * (COIN_SPAWN_INTERVAL_MAX_SEC - COIN_SPAWN_INTERVAL_MIN_SEC);\r\n  }\r\n\r\n  if (!s.isDying) {\r\n  for (let i = s.entities.length - 1; i >= 0; i--) {\r\n    const obs = s.entities[i]!;\r\n    obs.x -= (s.scrollSpeedX || speedX) * dtSec;\r\n    if (obs.x + obs.width < 0) {\r\n      s.entities.splice(i, 1);\r\n      continue;\r\n    }\r\n    if (\r\n      obs.x < s.player.x + s.player.width &&\r\n      obs.x + obs.width > s.player.x &&\r\n      obs.y < s.player.y + s.player.height &&\r\n      obs.y + obs.height > s.player.y\r\n    ) {\r\n      if (s.isDying) {\r\n        // во время анимации смерти игнорируем взаимодействия\r\n        continue;\r\n      }\r\n      // обработка столкновений по типу\r\n      if (obs.kind === 'heart' || obs.kind === 'coin') {\r\n        s.entities.splice(i, 1);\r\n        // counters for collectibles\r\n        if (obs.kind === 'coin') {\r\n          s.coinCount += 1;\r\n          s.uiDirty = true;\r\n        } else if (obs.kind === 'heart') {\r\n          if (s.lifeCount < 3) {\r\n            s.lifeCount += 1;\r\n            s.uiDirty = true;\r\n          }\r\n        }\r\n        // sfx для сбора предметов\r\n        if (obs.kind === 'coin') {\r\n          try { postMessage({ type: 'sfx', s: 'coin' } as WorkerOutMessage); } catch {}\r\n        } else if (obs.kind === 'heart') {\r\n          try { postMessage({ type: 'sfx', s: 'heart' } as WorkerOutMessage); } catch {}\r\n        }\r\n        // trigger reward one-shot animation\r\n        if (s.playerRewardFrames.length > 0) {\r\n          s.playerRewardPlaying = true;\r\n          s.playerRewardElapsedMs = 0;\r\n          s.playerRewardFrameIndex = 0;\r\n        }\r\n      } else {\r\n        s.entities.splice(i, 1);\r\n        // collision with obstacles reduces life by 1 (not below 0)\r\n        if (s.lifeCount > 0) {\r\n          s.lifeCount -= 1;\r\n          s.uiDirty = true;\r\n        }\r\n        // reset streak, enable relax cooldown\r\n        s.noHitSec = 0;\r\n        s.recentHitCooldownSec = Math.max(s.recentHitCooldownSec, SPAWN_CONFIG.scaling.relax.recentHitSecs);\r\n        // sfx для столкновений с препятствиями (для текущего удара)\r\n        // sfx для столкновений с препятствиями\r\n        if (obs.kind === 'blight') {\r\n          try { postMessage({ type: 'sfx', s: 'blight' } as WorkerOutMessage); } catch {}\r\n        } else if (obs.kind === 'skeleton') {\r\n          try { postMessage({ type: 'sfx', s: 'skeleton' } as WorkerOutMessage); } catch {}\r\n        }\r\n        // если жизни закончились — запускаем смерть (анимация + задержка gameover)\r\n        if (s.lifeCount <= 0 && !s.isDying) {\r\n          s.isDying = true;\r\n          s.dyingElapsedMs = 0;\r\n          s.gameOverSent = false;\r\n          s.pendingJump = false;\r\n          s.player.isJumping = false;\r\n          s.player.vy = 0;\r\n          s.player.y = groundY - s.player.height;\r\n          s.playerHitPlaying = false;\r\n          s.playerRewardPlaying = false;\r\n          try { postMessage({ type: 'death' } as WorkerOutMessage); } catch {}\r\n          if (s.playerDyingFrames.length > 0) {\r\n            s.playerDyingPlaying = true;\r\n            s.playerDyingElapsedMs = 0;\r\n            s.playerDyingFrameIndex = 0;\r\n          }\r\n        } else {\r\n          // trigger hit one-shot animation (если ещё не умер)\r\n          if (s.playerHitFrames.length > 0) {\r\n            s.playerHitPlaying = true;\r\n            s.playerHitElapsedMs = 0;\r\n            s.playerHitFrameIndex = 0;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  }\r\n\r\n  // Завершение: отправляем gameover спустя dyingDurationMs после смерти\r\n  if (s.isDying) {\r\n    s.dyingElapsedMs += dtSec * 1000;\r\n    if (!s.gameOverSent && s.dyingElapsedMs >= s.dyingDurationMs) {\r\n      s.gameOverSent = true;\r\n      try { postMessage({ type: 'gameover' } as WorkerOutMessage); } catch {}\r\n    }\r\n  }\r\n}\r\n\r\n\r\n","import type { GameState, PlayerAtlas } from './state';\r\n\r\nexport async function ensurePlayerSprite(s: GameState): Promise<void> {\r\n  if (!s.ctx) return;\r\n  if (s.playerSprite || s.playerAtlas || s.playerSpriteLoading) return;\r\n  if (!s.playerSpriteUrl || !s.playerAtlasUrl) return;\r\n  s.playerSpriteLoading = true;\r\n  try {\r\n    const [imgRes, jsonRes] = await Promise.all([\r\n      fetch(s.playerSpriteUrl),\r\n      fetch(s.playerAtlasUrl),\r\n    ]);\r\n    if (!imgRes.ok) throw new Error('Failed to fetch player sprite');\r\n    if (!jsonRes.ok) throw new Error('Failed to fetch player atlas');\r\n    const [imgBlob, atlas]: [Blob, PlayerAtlas] = [await imgRes.blob(), await jsonRes.json()];\r\n    const bmp = await createImageBitmap(imgBlob);\r\n    // Подготовим порядок кадров по X\r\n    const byX = (a: [string, any], b: [string, any]) => {\r\n      const ax = a[1].frame?.x ?? 0;\r\n      const bx = b[1].frame?.x ?? 0;\r\n      if (ax !== bx) return ax - bx;\r\n      const ai = parseInt(a[0].split('_')[1] || '0', 10);\r\n      const bi = parseInt(b[0].split('_')[1] || '0', 10);\r\n      return ai - bi;\r\n    };\r\n\r\n    const frames = atlas.frames || {};\r\n    const runEntries = Object.entries(frames).filter(([k]) => k.startsWith('run_')).sort(byX);\r\n    const jumpEntries = Object.entries(frames).filter(([k]) => k.startsWith('jump_')).sort(byX);\r\n    const hitEntries = Object.entries(frames).filter(([k]) => k.startsWith('hit_')).sort(byX);\r\n    const dyingEntries = Object.entries(frames).filter(([k]) => k.startsWith('dying_')).sort(byX);\r\n    const blightEntries = Object.entries(frames).filter(([k]) => k.startsWith('blight_')).sort(byX);\r\n    const heartEntries = Object.entries(frames).filter(([k]) => k.startsWith('heart_')).sort(byX);\r\n    const coinEntries = Object.entries(frames).filter(([k]) => k.startsWith('coin_')).sort(byX);\r\n    const skeletonEntries = Object.entries(frames).filter(([k]) => k.startsWith('skeleton_')).sort(byX);\r\n\r\n    // Приоритет animations из JSON\r\n    const pickValid = (names?: string[]) =>\r\n      (names || []).filter((n) => !!frames[n]);\r\n\r\n    const anims = atlas.animations || {};\r\n    let runNames = pickValid(anims.run);\r\n    let jumpNames = pickValid(anims.jump);\r\n    let hitNames = pickValid(anims.hit);\r\n    let rewardNames = pickValid(anims.reward);\r\n    let dyingNames = pickValid((anims as any).dying);\r\n    let blightNames = pickValid((anims as any).blight);\r\n    let heartNames = pickValid((anims as any).heart);\r\n    let coinName = pickValid((anims as any).coin)?.[0];\r\n    let coinNames = pickValid((anims as any).coin);\r\n    let skeletonNames = pickValid((anims as any).skeleton);\r\n\r\n    if (!runNames || runNames.length === 0) runNames = runEntries.map(([k]) => k);\r\n    if (!jumpNames || jumpNames.length === 0) jumpNames = jumpEntries.map(([k]) => k);\r\n    if (!hitNames || hitNames.length === 0) hitNames = hitEntries.map(([k]) => k);\r\n    if (!rewardNames || rewardNames.length === 0) rewardNames = Object.keys(frames).filter((k) => k.startsWith('reward_')).sort().map((k) => k);\r\n    if (!dyingNames || dyingNames.length === 0) dyingNames = dyingEntries.map(([k]) => k);\r\n    if (!blightNames || blightNames.length === 0) blightNames = blightEntries.map(([k]) => k);\r\n    if (!heartNames || heartNames.length === 0) heartNames = heartEntries.map(([k]) => k);\r\n    if (!coinName) coinName = coinEntries[0]?.[0];\r\n    if (!coinNames || coinNames.length === 0) coinNames = coinEntries.map(([k]) => k);\r\n    if (!skeletonNames || skeletonNames.length === 0) skeletonNames = skeletonEntries.map(([k]) => k);\r\n\r\n    s.playerRunFrames = runNames;\r\n    s.playerJumpFrames = jumpNames;\r\n    s.playerHitFrames = hitNames;\r\n    s.playerRewardFrames = rewardNames;\r\n    s.playerDyingFrames = dyingNames;\r\n    s.blightFrames = blightNames || [];\r\n    s.heartFrames = heartNames || [];\r\n    s.coinFrameName = coinName ?? null;\r\n    s.coinFrames = coinNames || [];\r\n    s.skeletonFrames = skeletonNames || [];\r\n    s.playerSprite = bmp;\r\n    s.playerAtlas = atlas;\r\n  } finally {\r\n    s.playerSpriteLoading = false;\r\n  }\r\n}\r\n\r\n\r\n","import type { GameState } from './state';\r\nimport { GAME_HEIGHT, groundY, speedX } from './constants';\r\nimport { playerConfig, entitiesConfig, GROUND_BOTTOM_MARGIN_CSS } from '@/config/visual';\r\nimport { ensurePlayerSprite } from './assets';\r\n\r\n\r\nexport function draw(s: GameState, alpha: number = 1, stepSec: number = 1 / 60): void {\r\n  if (!s.ctx || !s.canvas) return;\r\n\r\n  // Clear buffer\r\n  if (s.transparentBg) {\r\n    s.ctx.clearRect(0, 0, s.canvas.width, s.canvas.height);\r\n  } else {\r\n    s.ctx.fillStyle = s.skyColor;\r\n    s.ctx.fillRect(0, 0, s.canvas.width, s.canvas.height);\r\n  }\r\n\r\n  // Зафиксировать линию земли на GROUND_BOTTOM_MARGIN_CSS от низа холста:\r\n  // вычисляем вертикальное смещение так, чтобы top земли (groundY) попадал в cssH - GROUND_BOTTOM_MARGIN_CSS.\r\n  const groundTopCss = s.cssH - GROUND_BOTTOM_MARGIN_CSS;\r\n  const offsetYpx = Math.round((groundTopCss - groundY) * s.scale);\r\n\r\n  // (Ground removed)\r\n\r\n  // Player\r\n  const playerYInterp = s.prevPlayerY + (s.player.y - s.prevPlayerY) * alpha;\r\n  ensurePlayerSprite(s);\r\n  if (s.playerSprite && s.playerAtlas) {\r\n    // Выбор кадра по приоритету: dying → reward → hit → jump → run\r\n    let chosenName: string | null = null;\r\n    if (s.isDying && s.playerDyingFrames && s.playerDyingFrames.length > 0) {\r\n      chosenName = s.playerDyingFrames[Math.max(0, Math.min(s.playerDyingFrames.length - 1, s.playerDyingFrameIndex))] || null;\r\n    } else if (s.playerRewardPlaying && s.playerRewardFrames.length > 0) {\r\n      chosenName = s.playerRewardFrames[Math.max(0, Math.min(s.playerRewardFrames.length - 1, s.playerRewardFrameIndex))] || null;\r\n    } else if (s.playerHitPlaying && s.playerHitFrames.length > 0) {\r\n      chosenName = s.playerHitFrames[Math.max(0, Math.min(s.playerHitFrames.length - 1, s.playerHitFrameIndex))] || null;\r\n    } else if (s.player.isJumping && s.playerJumpFrames.length > 0) {\r\n      // В начале прыжка коротко показываем кадр бега, с которого стартовали\r\n      const total = s.playerJumpTotalMs || 1;\r\n      const pRaw = Math.max(0, Math.min(1, s.playerJumpElapsedMs / total));\r\n      const holdStart = 0.1; // 10% времени прыжка — стартовый кадр бега\r\n      if (pRaw < holdStart && s.playerRunFrames.length > 0) {\r\n        chosenName = s.playerRunFrames[Math.max(0, Math.min(s.playerRunFrames.length - 1, s.playerRunStartIndexAtJump))];\r\n      } else {\r\n        // Равномерное распределение по оставшемуся времени\r\n        const p = Math.max(0, Math.min(1, (pRaw - holdStart) / (1 - holdStart)));\r\n        const n = s.playerJumpFrames.length;\r\n        const idx = Math.max(0, Math.min(n - 1, Math.floor(p * (n - 1) + 1e-6)));\r\n        chosenName = s.playerJumpFrames[idx];\r\n      }\r\n    } else if (s.playerRunFrames.length > 0) {\r\n      chosenName = s.playerRunFrames[Math.max(0, Math.min(s.playerRunFrames.length - 1, s.playerAnimFrameIndex))];\r\n    }\r\n\r\n    const frFull = chosenName ? s.playerAtlas.frames[chosenName] : undefined;\r\n    const fr = frFull?.frame;\r\n    const pivot = frFull?.pivot || { x: 0.5, y: 1 };\r\n    if (fr) {\r\n      const destHcss = playerConfig.visualHeight;\r\n      const destWcss = (fr.w / fr.h) * destHcss;\r\n      const leftCss = s.player.x - pivot.x * destWcss + (playerConfig.offsetX || 0);\r\n      const bottomCss = playerYInterp + s.player.height + (playerConfig.offsetY || 0);\r\n      const topCss = bottomCss - destHcss * pivot.y;\r\n      const dx = Math.round(leftCss * s.scale);\r\n      const dy = Math.round((topCss) * s.scale + offsetYpx);\r\n      const dw = Math.max(1, Math.round(destWcss * s.scale));\r\n      const dh = Math.max(1, Math.round(destHcss * s.scale));\r\n      const prevSmooth = s.ctx.imageSmoothingEnabled;\r\n      s.ctx.imageSmoothingEnabled = false;\r\n      s.ctx.drawImage(\r\n        s.playerSprite,\r\n        fr.x, fr.y, fr.w, fr.h,\r\n        dx, dy, dw, dh\r\n      );\r\n      s.ctx.imageSmoothingEnabled = prevSmooth;\r\n    }\r\n  } else {\r\n    s.ctx.fillStyle = '#000';\r\n    s.ctx.fillRect(\r\n      Math.round(s.player.x * s.scale),\r\n      Math.round(playerYInterp * s.scale + offsetYpx),\r\n      Math.round(s.player.width * s.scale),\r\n      Math.round(s.player.height * s.scale)\r\n    );\r\n  }\r\n  // Debug: player hitbox overlay\r\n  if (s.debugDrawHitboxes) {\r\n    const dx = Math.round(s.player.x * s.scale);\r\n    const dy = Math.round(playerYInterp * s.scale + offsetYpx);\r\n    const dw = Math.round(s.player.width * s.scale);\r\n    const dh = Math.round(s.player.height * s.scale);\r\n    s.ctx.save();\r\n    s.ctx.globalAlpha = 0.3;\r\n    s.ctx.fillStyle = '#ff00ff';\r\n    s.ctx.fillRect(dx, dy, dw, dh);\r\n    s.ctx.globalAlpha = 1;\r\n    s.ctx.lineWidth = Math.max(1, Math.round(s.scale));\r\n    s.ctx.strokeStyle = '#ff00ff';\r\n    s.ctx.strokeRect(dx, dy, dw, dh);\r\n    s.ctx.restore();\r\n  }\r\n\r\n  // Entities (не рисуем во время анимации смерти игрока)\r\n  if (!s.isDying) for (const obs of s.entities) {\r\n    const obsXInterp = obs.x + speedX * stepSec * (1 - alpha);\r\n    const dxCss = obsXInterp;\r\n    const dyCss = obs.y;\r\n    // если есть атласные спрайты — рисуем их, иначе fallback прямоугольником\r\n    if (s.playerSprite && s.playerAtlas && (obs.kind === 'blight' || obs.kind === 'skeleton' || obs.kind === 'heart' || obs.kind === 'coin')) {\r\n      const name =\r\n        obs.kind === 'blight'\r\n          ? (s.blightFrames.length > 0\r\n              ? s.blightFrames[Math.max(0, Math.min(s.blightFrames.length - 1, s.blightAnimFrameIndex))]\r\n              : null)\r\n          : (obs.kind === 'skeleton'\r\n              ? (s.skeletonFrames.length > 0\r\n                  ? s.skeletonFrames[Math.max(0, Math.min(s.skeletonFrames.length - 1, s.skeletonAnimFrameIndex))]\r\n                  : null)\r\n            : (obs.kind === 'heart'\r\n                ? (s.heartFrames.length > 0\r\n                    ? s.heartFrames[Math.max(0, Math.min(s.heartFrames.length - 1, s.heartAnimFrameIndex))]\r\n                    : null)\r\n                  : (s.coinFrames.length > 0\r\n                      ? s.coinFrames[Math.max(0, Math.min(s.coinFrames.length - 1, s.coinAnimFrameIndex))]\r\n                      : s.coinFrameName)));\r\n      const frFull = name ? s.playerAtlas.frames[name] : undefined;\r\n      const fr = frFull?.frame;\r\n      const pivot = frFull?.pivot || { x: 0.5, y: 1 };\r\n      if (fr) {\r\n        const cfg = entitiesConfig[obs.kind];\r\n        const destHcss = cfg.visualHeight;\r\n        const destWcss = (fr.w / fr.h) * destHcss;\r\n        const leftCss = dxCss - pivot.x * destWcss + obs.width * 0.5 + (cfg.offsetX || 0); // центр по хитбоксу\r\n        const bottomCss = dyCss + obs.height + (cfg.offsetY || 0);\r\n        const topCss = bottomCss - destHcss * pivot.y;\r\n        const dx = Math.round(leftCss * s.scale);\r\n        const dy = Math.round((topCss) * s.scale + offsetYpx);\r\n        const dw = Math.max(1, Math.round(destWcss * s.scale));\r\n        const dh = Math.max(1, Math.round(destHcss * s.scale));\r\n        const prevSmooth = s.ctx.imageSmoothingEnabled;\r\n        s.ctx.imageSmoothingEnabled = false;\r\n        s.ctx.drawImage(\r\n          s.playerSprite,\r\n          fr.x, fr.y, fr.w, fr.h,\r\n          dx, dy, dw, dh\r\n        );\r\n        s.ctx.imageSmoothingEnabled = prevSmooth;\r\n        // Debug: entity hitbox overlay (for atlas branch)\r\n        if (s.debugDrawHitboxes) {\r\n          const hbDx = Math.round(dxCss * s.scale);\r\n          const hbDy = Math.round(dyCss * s.scale + offsetYpx);\r\n          const hbDw = Math.round(obs.width * s.scale);\r\n          const hbDh = Math.round(obs.height * s.scale);\r\n          s.ctx.save();\r\n          s.ctx.globalAlpha = 0.3;\r\n          s.ctx.fillStyle = '#ff00ff';\r\n          s.ctx.fillRect(hbDx, hbDy, hbDw, hbDh);\r\n          s.ctx.globalAlpha = 1;\r\n          s.ctx.lineWidth = Math.max(1, Math.round(s.scale));\r\n          s.ctx.strokeStyle = '#ff00ff';\r\n          s.ctx.strokeRect(hbDx, hbDy, hbDw, hbDh);\r\n          s.ctx.restore();\r\n        }\r\n        continue;\r\n      }\r\n    }\r\n    // Fallback rectangle\r\n    s.ctx.fillStyle = obs.kind === 'heart' ? '#0a0' : (obs.kind === 'coin' ? '#fc0' : 'red');\r\n    s.ctx.fillRect(\r\n      Math.round(dxCss * s.scale),\r\n      Math.round(dyCss * s.scale + offsetYpx),\r\n      Math.round(obs.width * s.scale),\r\n      Math.round(obs.height * s.scale)\r\n    );\r\n\r\n    // Debug: entity hitbox overlay\r\n    if (s.debugDrawHitboxes) {\r\n      const dx = Math.round(dxCss * s.scale);\r\n      const dy = Math.round(dyCss * s.scale + offsetYpx);\r\n      const dw = Math.round(obs.width * s.scale);\r\n      const dh = Math.round(obs.height * s.scale);\r\n      s.ctx.save();\r\n      s.ctx.globalAlpha = 0.3;\r\n      s.ctx.fillStyle = '#ff00ff';\r\n      s.ctx.fillRect(dx, dy, dw, dh);\r\n      s.ctx.globalAlpha = 1;\r\n      s.ctx.lineWidth = Math.max(1, Math.round(s.scale));\r\n      s.ctx.strokeStyle = '#ff00ff';\r\n      s.ctx.strokeRect(dx, dy, dw, dh);\r\n      s.ctx.restore();\r\n    }\r\n  }\r\n}\r\n\r\n\r\n","// Offscreen worker entry (wiring)\r\nimport type { WorkerInMessage, WorkerOutMessage } from '@/types/workerMessages';\r\nimport { state, applyCanvasSize } from './worker/state';\r\nimport { update } from './worker/logic';\r\nimport { draw } from './worker/render';\r\n\r\nfunction markReady() {\r\n  if (state.ready) return;\r\n  state.ready = true;\r\n  postMessage({ type: 'ready' } as WorkerOutMessage);\r\n}\r\n\r\n// Timing loop (driven by main rAF) with fixed simulation step\r\nlet lastNow = 0;\r\nlet accMs = 0;\r\nconst FIXED_DT_MS = 1000 / 60;\r\nconst MAX_FRAME_DT_MS = 100; // clamp spikes; prevents huge catch-up\r\nconst MAX_CATCHUP_STEPS = 5; // avoid spiral of death\r\n\r\nfunction frame(now: number) {\r\n  if (!state.ready) return; // wait handshake\r\n  if (!lastNow) lastNow = now;\r\n  let dtMs = now - lastNow;\r\n  lastNow = now;\r\n  if (dtMs < 0) dtMs = 0;\r\n  if (dtMs > MAX_FRAME_DT_MS) dtMs = MAX_FRAME_DT_MS;\r\n\r\n  // fixed-timestep simulation\r\n  accMs += dtMs;\r\n  let steps = 0;\r\n  while (accMs >= FIXED_DT_MS && steps < MAX_CATCHUP_STEPS) {\r\n    update(state, FIXED_DT_MS / 1000);\r\n    accMs -= FIXED_DT_MS;\r\n    steps++;\r\n  }\r\n\r\n  state.uiElapsedMs += dtMs;\r\n  if (state.uiDirty && state.uiElapsedMs >= state.uiIntervalMs) {\r\n    postMessage({ type: 'ui', coinCount: state.coinCount, lifeCount: state.lifeCount } as WorkerOutMessage);\r\n    state.uiDirty = false; state.uiElapsedMs = 0;\r\n  }\r\n\r\n  // draw on each rAF tick from main\r\n  const alpha = Math.max(0, Math.min(1, accMs / FIXED_DT_MS));\r\n  draw(state, alpha, FIXED_DT_MS / 1000);\r\n}\r\n\r\nonmessage = (ev: MessageEvent<WorkerInMessage>) => {\r\n  const data = ev.data || ({} as WorkerInMessage);\r\n  switch (data.type) {\r\n    case 'init': {\r\n      state.canvas = data.canvas;\r\n      state.skyColor = typeof data.skyColor === 'string' ? data.skyColor : state.skyColor;\r\n      state.expectResize = !!data.expectResize;\r\n      (state as any).debugDrawHitboxes = !!(data as any).debugHitboxes;\r\n\r\n      const wantAlpha = !!(data as any).alpha;\r\n      state.ctx = state.canvas.getContext('2d', { alpha: wantAlpha });\r\n      if (!state.ctx) return;\r\n      state.ctx.imageSmoothingEnabled = false;\r\n\r\n      (state as any).transparentBg = !!(data as any).transparentBg;\r\n\r\n      applyCanvasSize(state, data.cssW, data.cssH, data.dpr);\r\n\r\n      if (state.expectResize) {\r\n        if (state.readyTimer) clearTimeout(state.readyTimer);\r\n        state.readyTimer = setTimeout(() => { markReady(); }, 200) as unknown as number;\r\n      } else {\r\n        markReady();\r\n      }\r\n      break;\r\n    }\r\n    case 'resize': {\r\n      applyCanvasSize(state, data.cssW, data.cssH, data.dpr);\r\n      if (state.expectResize) {\r\n        state.expectResize = false;\r\n        if (state.readyTimer) { clearTimeout(state.readyTimer); state.readyTimer = null; }\r\n        markReady();\r\n      }\r\n      break;\r\n    }\r\n    case 'frame': {\r\n      frame(typeof data.now === 'number' ? data.now : performance.now());\r\n      break;\r\n    }\r\n    case 'vis': {\r\n      // сброс тайминга при смене видимости, чтобы избежать рывка\r\n      lastNow = 0;\r\n      accMs = 0;\r\n      break;\r\n    }\r\n    case 'input': {\r\n      if (data.tap || data.space) {\r\n        // Принимаем ввод прыжка всегда (двойной прыжок обрабатывается в логике)\r\n        if (!state.isDying && state.lifeCount > 0) state.pendingJump = true;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n"],"names":["SPAWN_CONFIG","SPAWN_INTERVAL_MIN_SEC","SPAWN_INTERVAL_MAX_SEC","HEART_BASE_PROB","HEART_MIN_GAP_OBS","HEART_MAX_GAP_OBS","SKELETON_IN_NEGATIVE_PROB","COIN_SPAWN_INTERVAL_MIN_SEC","COIN_SPAWN_INTERVAL_MAX_SEC","MAX_W_PX","MAX_H_PX","playerConfig","entitiesConfig","GROUND_BOTTOM_MARGIN_CSS","playerSpriteUrlObj","playerAtlasUrlObj","state","applyCanvasSize","s","newCssW","newCssH","dpr","rawDpr","areaCss","maxAreaPx","dprByCaps","perfCap","dprClamped","x","sW","sH","bound","uniform","targetWpx","targetHpx","SPEED_CONFIG","computeSpeedMultiplier","elapsedSec","t","ease","span","REACTION_CONFIG","computeReactionTimeSec","update","dtSec","mult","JUMP_BUFFER_MS","COYOTE_WINDOW_MS","MIN_DOUBLE_JUMP_DELAY_MS","canGroundJump","canDoubleJump","firstJump","roll","bucket","tNorm","skeletonProb","isSkeleton","airSec","reactSec","minGapSec","minTimeGapCss","lastNeg","j","e","minHorzGapCss","spawnX","cfg","last","airSec2","reactSec2","minGapSec2","minTimeGapCss2","minHorzGapCss2","spawnX2","secondIsSkeleton","heartH","apexDouble","bottomY2","y","baseNext","coinH","apex","bottomY","i","obs","ensurePlayerSprite","imgRes","jsonRes","imgBlob","atlas","bmp","byX","a","b","ax","bx","ai","bi","frames","runEntries","k","jumpEntries","hitEntries","dyingEntries","blightEntries","heartEntries","coinEntries","skeletonEntries","pickValid","names","n","anims","runNames","jumpNames","hitNames","rewardNames","dyingNames","blightNames","heartNames","coinName","coinNames","skeletonNames","draw","alpha","stepSec","groundTopCss","offsetYpx","playerYInterp","chosenName","total","pRaw","holdStart","p","idx","frFull","fr","pivot","destHcss","destWcss","leftCss","topCss","dx","dy","dw","dh","prevSmooth","dxCss","dyCss","name","hbDx","hbDy","hbDw","hbDh","markReady","lastNow","accMs","FIXED_DT_MS","MAX_FRAME_DT_MS","MAX_CATCHUP_STEPS","frame","now","dtMs","steps","ev","data","wantAlpha"],"mappings":"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"}