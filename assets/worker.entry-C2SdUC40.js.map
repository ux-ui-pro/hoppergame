{"version":3,"file":"worker.entry-C2SdUC40.js","sources":["../src/config/visual.ts","../src/config/physics.ts","../src/config/spawn.ts","../src/game/worker/constants.ts","../src/game/worker/state.ts","../src/game/worker/logic.ts","../src/game/worker/assets.ts","../src/game/worker/render.ts","../src/game/worker.entry.ts"],"sourcesContent":["import type { Entity } from '@/types/game';\n\nexport interface VisualCfg {\n  hitboxW: number;      // CSS px\n  hitboxH: number;      // CSS px\n  visualHeight: number; // CSS px\n  offsetX: number;      // CSS px, +вправо\n  offsetY: number;      // CSS px, +вверх (к нижней грани хитбокса)\n}\n\nexport const playerConfig: VisualCfg = {\n  hitboxW: 20,\n  hitboxH: 60,\n  visualHeight: 80,\n  offsetX: 5,\n  offsetY: 0,\n};\n\ntype Kind = Entity['kind'];\n\nexport const entitiesConfig: Record<Kind, VisualCfg> = {\n  blight: {\n    hitboxW: 30,\n    hitboxH: 40,\n    visualHeight: 80,\n    offsetX: 4,\n    offsetY: 0,\n  },\n  skeleton: {\n    hitboxW: 20,\n    hitboxH: 60,\n    visualHeight: 80,\n    offsetX: -7,\n    offsetY: 0,\n  },\n  heart: {\n    hitboxW: 16,\n    hitboxH: 16,\n    visualHeight: 80,\n    offsetX: 0,\n    offsetY: 28,\n  },\n  coin: {\n    hitboxW: 24,\n    hitboxH: 24,\n    visualHeight: 80,\n    offsetX: 0,\n    offsetY: 30,\n  },\n};\n\n// На сколько CSS‑px линия земли (top) прижата вверх от нижней границы холста.\n// Используется рендером для вычисления вертикального смещения сцены.\nexport const GROUND_BOTTOM_MARGIN_CSS = 160;\n","export const GAME_HEIGHT = 600;\nexport const groundY = GAME_HEIGHT - 50;\n\n// Скорости/ускорения в CSS‑пикселях в секунду\nexport const speedX = 4 * 60;\nexport const gravityAccel = (12 * 60) / (1 / 3);\nexport const jumpVelocity = 12 * 60;\n","// Конфиг появления объектов сцены\n\nexport const SPAWN_CONFIG = {\n  obstacles: {\n    // Интервалы основного потока спавна (сек) — препятствия и сердца распределяются внутри\n    intervalMinSec: 1.0,\n    intervalMaxSec: 1.9,\n    // Доля скелетов среди негативных препятствий (остальное — blight)\n    skeletonInNegativeProb: 0.35,\n  },\n  heart: {\n    // Базовая вероятность появления сердца внутри основного потока\n    baseProb: 0.01,\n    // Ограничение «случайности» между сердцами (в количестве препятствий)\n    minGapObs: 9,\n    maxGapObs: 15,\n  },\n  coin: {\n    // Независимый поток спавна монет (сек)\n    intervalMinSec: 1.5,\n    intervalMaxSec: 3,\n  },\n  scaling: {\n    // До какого времени плавно усиливать сложность (сек)\n    targetSec: 180,\n    // Нижняя граница мультипликатора интервалов спавна (уменьшает интервалы, 0.6 = на 40% быстрее)\n    minMultiplier: 0.4,\n    // Минимально допустимый безопасный зазор между препятствиями (сек) — из физики прыжка\n    minSafeGapSec: 0.7,\n    // Вклад монет: при 100 монетах — до 30% ускорения интервалов\n    coinFullScale: 100,\n    coinFactor: 0.25,\n    // Вклад «стрику без ударов»: при 30 сек — до 20% ускорения\n    streakFullSec: 30,\n    streakFactor: 0.125,\n    // Анти‑фрустрация после удара/при низких жизнях\n    relax: {\n      whenLifeLE: 1,\n      recentHitSecs: 5,\n      relaxMultiplier: 1.15,\n    },\n    // «Окна отдыха» при максимальной плотности\n    rest: {\n      whenMultiplierLE: 0.7,   // раньше включаем окна (чуть менее экстремальная сложность)\n      probability: 0.4,        // чаще вставляем окно отдыха\n      gapMultiplier: 4.0,      // длиннее окно: 4 × minSafeGapSec\n      cooldownSec: 5,          // немного чаще, короче кулдаун\n    },\n  },\n} as const;\n","import { GAME_HEIGHT, groundY, speedX, gravityAccel, jumpVelocity } from '@/config/physics';\nimport { SPAWN_CONFIG } from '@/config/spawn';\n\nexport { GAME_HEIGHT, groundY, speedX, gravityAccel, jumpVelocity };\n\n// Механика земли/поверхности вынесена в другие модули\n\n// Интервал спавна препятствий (сек): берём из конфига\nexport const SPAWN_INTERVAL_MIN_SEC = SPAWN_CONFIG.obstacles.intervalMinSec;\nexport const SPAWN_INTERVAL_MAX_SEC = SPAWN_CONFIG.obstacles.intervalMaxSec;\n\n// Ограничение «случайности» появления сердца\nexport const HEART_BASE_PROB = SPAWN_CONFIG.heart.baseProb;\nexport const HEART_MIN_GAP_OBS = SPAWN_CONFIG.heart.minGapObs;\nexport const HEART_MAX_GAP_OBS = SPAWN_CONFIG.heart.maxGapObs;\n// Доля скелетов среди «негативных» препятствий (остальное — blight)\nexport const SKELETON_IN_NEGATIVE_PROB = SPAWN_CONFIG.obstacles.skeletonInNegativeProb;\n\n// Монеты: независимый спавн (сек)\nexport const COIN_SPAWN_INTERVAL_MIN_SEC = SPAWN_CONFIG.coin.intervalMinSec;\nexport const COIN_SPAWN_INTERVAL_MAX_SEC = SPAWN_CONFIG.coin.intervalMaxSec;\n// Ограничения буфера рендера (в device‑px)\nexport const MAX_W_PX = 3072;\nexport const MAX_H_PX = 3072;\n","import type { Player, Entity } from '@/types/game';\nimport { playerConfig } from '@/config/visual';\n\nimport {\n  GAME_HEIGHT,\n  groundY,\n  MAX_W_PX,\n  MAX_H_PX,\n  gravityAccel,\n  jumpVelocity,\n  SPAWN_INTERVAL_MIN_SEC,\n  SPAWN_INTERVAL_MAX_SEC,\n} from './constants';\n\nexport interface AtlasFrameRect { x: number; y: number; w: number; h: number; }\nexport interface AtlasFrame {\n  frame: AtlasFrameRect;\n  rotated: boolean;\n  trimmed: boolean;\n  spriteSourceSize: AtlasFrameRect;\n  sourceSize: { w: number; h: number };\n  pivot: { x: number; y: number };\n}\nexport interface PlayerAtlas {\n  meta: {\n    image: string;\n    size: { w: number; h: number };\n    scale: number | string;\n    frameWidth?: number;\n    frameHeight?: number;\n  };\n  frames: Record<string, AtlasFrame>;\n  animations?: {\n    run?: string[];\n    jump?: string[];\n    hit?: string[];\n    reward?: string[];\n    dying?: string[];\n    blight?: string[];\n    heart?: string[];\n    coin?: string[];\n    skeleton?: string[];\n    [key: string]: string[] | undefined;\n  };\n}\n\nexport interface GameState {\n  ctx: OffscreenCanvasRenderingContext2D | null;\n  canvas: OffscreenCanvas | null;\n\n  cssW: number;\n  cssH: number;\n  scale: number;\n\n  // Прозрачность буфера\n  transparentBg: boolean;\n\n  // Этап «рукопожатия» готовности воркера\n  ready: boolean;\n  expectResize: boolean;\n  readyTimer: number | null;\n\n  // Мир/игровое состояние\n  coinCount: number;\n  lifeCount: number;\n  uiDirty: boolean;\n  uiElapsedMs: number;\n  uiIntervalMs: number;\n  // Параметры динамической сложности\n  elapsedSec: number;\n  noHitSec: number;\n  recentHitCooldownSec: number;\n  restCooldownSec: number;\n\n  player: Player;\n  entities: Entity[];\n  spawnTimerSec: number;\n  nextSpawnSec: number;\n  pendingJump: boolean;\n  // Сколько препятствий прошло с момента последнего появления сердца\n  sinceLastHeartCount: number;\n  // Независимый спавнер монет\n  coinSpawnTimerSec: number;\n  coinNextSpawnSec: number;\n\n  // Параметры визуала\n  skyColor: string;\n  // Отладка\n  debugDrawHitboxes?: boolean;\n\n  // Спрайт/атлас игрока\n  playerSpriteUrl: string;\n  playerAtlasUrl: string;\n  playerSprite: ImageBitmap | null;\n  playerAtlas: PlayerAtlas | null;\n  playerSpriteLoading: boolean;\n  playerRunFrames: string[];\n  playerJumpFrames: string[];\n  playerHitFrames: string[];\n  playerRewardFrames: string[];\n  // Кадры анимации смерти\n  playerDyingFrames: string[];\n  blightFrames: string[];\n  heartFrames: string[];\n  coinFrameName: string | null;\n  coinFrames: string[];\n  blightAnimElapsedMs: number;\n  blightAnimFrameIndex: number;\n  skeletonFrames: string[];\n  heartAnimElapsedMs: number;\n  heartAnimFrameIndex: number;\n  coinAnimElapsedMs: number;\n  coinAnimFrameIndex: number;\n  skeletonAnimElapsedMs: number;\n  skeletonAnimFrameIndex: number;\n  playerAnimFps: number;\n  playerAnimFrameMs: number;\n  playerAnimElapsedMs: number;\n  playerAnimFrameIndex: number;\n  // Сохранение фазы бега на время прыжка\n  playerRunStartIndexAtJump: number;\n  playerRunPhaseMsDuringJump: number;\n  // Тайминг прыжка (для выбора кадров по времени)\n  playerJumpElapsedMs: number;\n  playerJumpTotalMs: number;\n  // Состояние однократной анимации удара\n  playerHitPlaying: boolean;\n  playerHitElapsedMs: number;\n  playerHitFrameIndex: number;\n  // Состояние однократной анимации награды\n  playerRewardPlaying: boolean;\n  playerRewardElapsedMs: number;\n  playerRewardFrameIndex: number;\n  // Состояние смерти\n  isDying: boolean;\n  dyingElapsedMs: number;\n  dyingDurationMs: number;\n  gameOverSent: boolean;\n  // Состояние анимации смерти\n  playerDyingPlaying: boolean;\n  playerDyingElapsedMs: number;\n  playerDyingFrameIndex: number;\n\n  // Снапшот предыдущего шага (для интерполяции в рендере)\n  prevPlayerY: number;\n\n}\n\nconst playerSpriteUrlObj = new URL('../../assets/images/webp/runner-sprite-sheet.webp', import.meta.url);\nconst playerAtlasUrlObj = new URL('../../assets/images/webp/runner-sprite-sheet.json', import.meta.url);\n\nexport const state: GameState = {\n  ctx: null,\n  canvas: null,\n\n  cssW: 0,\n  cssH: 0,\n  scale: 1,\n\n  transparentBg: false,\n\n  ready: false,\n  expectResize: false,\n  readyTimer: null,\n\n  coinCount: 0,\n  lifeCount: 3,\n  uiDirty: true,\n  uiElapsedMs: 0,\n  uiIntervalMs: 120,\n  elapsedSec: 0,\n  noHitSec: 0,\n  recentHitCooldownSec: 0,\n  restCooldownSec: 0,\n\n  player: {\n    x: 0,\n    y: groundY - playerConfig.hitboxH,\n    width: playerConfig.hitboxW,\n    height: playerConfig.hitboxH,\n    vy: 0,\n    isJumping: false,\n  },\n  entities: [],\n  spawnTimerSec: 0,\n  sinceLastHeartCount: 0,\n  nextSpawnSec: SPAWN_INTERVAL_MIN_SEC + Math.random() * (SPAWN_INTERVAL_MAX_SEC - SPAWN_INTERVAL_MIN_SEC),\n  pendingJump: false,\n  coinSpawnTimerSec: 0,\n  coinNextSpawnSec: 0, // будет установлено при первом тике по COIN_SPAWN_INTERVAL_*\n\n  skyColor: '#e0f7fa',\n  debugDrawHitboxes: false,\n\n  playerSpriteUrl: playerSpriteUrlObj.toString(),\n  playerAtlasUrl: playerAtlasUrlObj.toString(),\n  playerSprite: null,\n  playerAtlas: null,\n  playerSpriteLoading: false,\n  playerRunFrames: [],\n  playerJumpFrames: [],\n  playerHitFrames: [],\n  playerRewardFrames: [],\n  playerDyingFrames: [],\n  blightFrames: [],\n  heartFrames: [],\n  coinFrameName: null,\n  coinFrames: [],\n  blightAnimElapsedMs: 0,\n  blightAnimFrameIndex: 0,\n  skeletonFrames: [],\n  heartAnimElapsedMs: 0,\n  heartAnimFrameIndex: 0,\n  coinAnimElapsedMs: 0,\n  coinAnimFrameIndex: 0,\n  skeletonAnimElapsedMs: 0,\n  skeletonAnimFrameIndex: 0,\n  playerAnimFps: 12,\n  playerAnimFrameMs: 1000 / 12,\n  playerAnimElapsedMs: 0,\n  playerAnimFrameIndex: 0,\n  playerRunStartIndexAtJump: 0,\n  playerRunPhaseMsDuringJump: 0,\n  playerJumpElapsedMs: 0,\n  playerJumpTotalMs: (2 * Math.abs(jumpVelocity) / Math.abs(gravityAccel)) * 1000,\n  playerHitPlaying: false,\n  playerHitElapsedMs: 0,\n  playerHitFrameIndex: 0,\n  playerRewardPlaying: false,\n  playerRewardElapsedMs: 0,\n  playerRewardFrameIndex: 0,\n  isDying: false,\n  dyingElapsedMs: 0,\n  dyingDurationMs: 2000,\n  gameOverSent: false,\n  playerDyingPlaying: false,\n  playerDyingElapsedMs: 0,\n  playerDyingFrameIndex: 0,\n\n  prevPlayerY: groundY - playerConfig.hitboxH,\n};\n\n/**\n * Сброс динамического игрового состояния для нового захода\n * (жизни/монеты, таймеры сложности, сущности, прыжок, смерть и анимации),\n * без пересоздания канваса/контекста и переинициализации ассетов.\n */\nexport function resetGameStateRuntime(s: GameState): void {\n  // Счётчики и UI\n  s.coinCount = 0;\n  s.lifeCount = 3;\n  s.uiDirty = true;\n  s.uiElapsedMs = 0;\n\n  // Таймеры сложности\n  s.elapsedSec = 0;\n  s.noHitSec = 0;\n  s.recentHitCooldownSec = 0;\n  s.restCooldownSec = 0;\n\n  // Игрок\n  s.player.x = s.cssW * 0.14;\n  s.player.y = groundY - playerConfig.hitboxH;\n  s.player.vy = 0;\n  s.player.isJumping = false;\n\n  // Предыдущая позиция для интерполяции\n  s.prevPlayerY = s.player.y;\n\n  // Сущности и спавн\n  s.entities = [];\n  s.spawnTimerSec = 0;\n  s.sinceLastHeartCount = 0;\n  s.nextSpawnSec =\n    SPAWN_INTERVAL_MIN_SEC +\n    Math.random() * (SPAWN_INTERVAL_MAX_SEC - SPAWN_INTERVAL_MIN_SEC);\n  s.pendingJump = false;\n\n  // Спавн монет\n  s.coinSpawnTimerSec = 0;\n  s.coinNextSpawnSec = 0; // будет пересчитан на первом тике\n\n  // Анимации игрока\n  s.playerAnimElapsedMs = 0;\n  s.playerAnimFrameIndex = 0;\n  s.playerRunStartIndexAtJump = 0;\n  s.playerRunPhaseMsDuringJump = 0;\n  s.playerJumpElapsedMs = 0;\n\n  // Однократные анимации удара/награды\n  s.playerHitPlaying = false;\n  s.playerHitElapsedMs = 0;\n  s.playerHitFrameIndex = 0;\n  s.playerRewardPlaying = false;\n  s.playerRewardElapsedMs = 0;\n  s.playerRewardFrameIndex = 0;\n\n  // Состояние смерти и gameover\n  s.isDying = false;\n  s.dyingElapsedMs = 0;\n  s.gameOverSent = false;\n  s.playerDyingPlaying = false;\n  s.playerDyingElapsedMs = 0;\n  s.playerDyingFrameIndex = 0;\n\n  // Анимации сущностей\n  s.blightAnimElapsedMs = 0;\n  s.blightAnimFrameIndex = 0;\n  s.heartAnimElapsedMs = 0;\n  s.heartAnimFrameIndex = 0;\n  s.coinAnimElapsedMs = 0;\n  s.coinAnimFrameIndex = 0;\n  s.skeletonAnimElapsedMs = 0;\n  s.skeletonAnimFrameIndex = 0;\n}\n\n\nexport function applyCanvasSize(s: GameState, newCssW: number, newCssH: number, dpr: number): void {\n  s.cssW = Math.max(1, Math.floor(newCssW));\n  s.cssH = Math.max(1, Math.floor(newCssH));\n\n  // Адаптивный кламп DPR: учитываем капы буфера, размер контейнера и производительность\n  const rawDpr = Math.max(dpr || 1, 1);\n  const areaCss = Math.max(1, s.cssW * s.cssH);\n  const maxAreaPx = MAX_W_PX * MAX_H_PX;\n  const dprByCaps = Math.max(1, Math.sqrt(maxAreaPx / areaCss));\n  const perfCap = (s.cssW >= 1024 || s.cssH >= 1024) ? 2 : 3;\n  const quantize = (x: number) => Math.max(1, Math.round(x / 0.25) * 0.25);\n  const dprClamped = quantize(Math.min(rawDpr, dprByCaps, perfCap));\n\n  const sW = MAX_W_PX / s.cssW;\n  const sH = MAX_H_PX / s.cssH;\n\n  let bound: 'dpr' | 'w' | 'h' = 'dpr';\n  let uniform = dprClamped;\n  if (sW < uniform) { uniform = sW; bound = 'w'; }\n  if (sH < uniform) { uniform = sH; bound = 'h'; }\n  s.scale = Math.max(1 / 8, uniform);\n\n  let targetWpx = 0;\n  let targetHpx = 0;\n  if (bound === 'h') {\n    targetHpx = Math.max(1, Math.floor(s.cssH * s.scale));\n    targetWpx = Math.max(1, Math.round(targetHpx * (s.cssW / s.cssH)));\n  } else if (bound === 'w') {\n    targetWpx = Math.max(1, Math.floor(s.cssW * s.scale));\n    targetHpx = Math.max(1, Math.round(targetWpx * (s.cssH / s.cssW)));\n  } else {\n    targetWpx = Math.max(1, Math.round(s.cssW * s.scale));\n    targetHpx = Math.max(1, Math.round(s.cssH * s.scale));\n  }\n\n  if (!s.canvas || !s.ctx) return;\n\n  if (s.canvas.width !== targetWpx) s.canvas.width = targetWpx;\n  if (s.canvas.height !== targetHpx) s.canvas.height = targetHpx;\n\n  s.player.x = s.cssW * 0.14;\n}\n\nexport { GAME_HEIGHT, groundY };\n","import type { WorkerOutMessage } from '@/types/workerMessages';\nimport { SPAWN_CONFIG } from '@/config/spawn';\nimport { entitiesConfig } from '@/config/visual';\n\nimport type { GameState } from './state';\nimport {\n  groundY,\n  speedX,\n  gravityAccel,\n  jumpVelocity,\n  SPAWN_INTERVAL_MIN_SEC,\n  SPAWN_INTERVAL_MAX_SEC,\n  HEART_BASE_PROB,\n  HEART_MIN_GAP_OBS,\n  HEART_MAX_GAP_OBS,\n  COIN_SPAWN_INTERVAL_MIN_SEC,\n  COIN_SPAWN_INTERVAL_MAX_SEC,\n  SKELETON_IN_NEGATIVE_PROB,\n} from './constants';\n\nfunction easeInOutQuad(x: number): number {\n  const t = Math.max(0, Math.min(1, x));\n  return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;\n}\n\nfunction getSpawnIntervalMultiplier(s: GameState): number {\n  const sc = SPAWN_CONFIG.scaling;\n  const tNorm = Math.max(0, Math.min(1, s.elapsedSec / sc.targetSec));\n  const mTime = 1 - (1 - sc.minMultiplier) * easeInOutQuad(tNorm); // от 1 к minMultiplier\n  const mCoin = 1 - sc.coinFactor * Math.max(0, Math.min(1, s.coinCount / sc.coinFullScale));\n  const mStreak = 1 - sc.streakFactor * Math.max(0, Math.min(1, s.noHitSec / sc.streakFullSec));\n  let m = mTime * mCoin * mStreak;\n  // Ограничиваем множитель снизу и сверху\n  m = Math.max(sc.minMultiplier, Math.min(1, m));\n  // «Анти‑фрустрация» при малом числе жизней или свежем ударе\n  if (s.lifeCount <= sc.relax.whenLifeLE || s.recentHitCooldownSec > 0) {\n    m *= sc.relax.relaxMultiplier;\n  }\n  // верхняя граница 1.3 чтобы не разносило интервал после релакса\n  return Math.max(0.4, Math.min(1.3, m));\n}\n\nfunction updateDifficultyTimers(s: GameState, dtSec: number): void {\n  s.elapsedSec += dtSec;\n  s.noHitSec += dtSec;\n  if (s.recentHitCooldownSec > 0) {\n    s.recentHitCooldownSec = Math.max(0, s.recentHitCooldownSec - dtSec);\n  }\n  if (s.restCooldownSec > 0) {\n    s.restCooldownSec = Math.max(0, s.restCooldownSec - dtSec);\n  }\n}\n\nfunction updatePlayerJumpState(s: GameState, dtSec: number): void {\n  if (!s.isDying) {\n    if (!s.player.isJumping && s.pendingJump) {\n      s.player.isJumping = true;\n      s.player.vy = -jumpVelocity;\n      s.pendingJump = false;\n      // уведомим главный поток о старте прыжка (для SFX)\n      try {\n        postMessage({ type: 'sfx', s: 'jump' } as WorkerOutMessage);\n      } catch {\n        // игнорируем ошибки отправки сообщения о звуке прыжка\n      }\n      // зафиксировать фазу бега и обнулить накопление на период прыжка\n      s.playerRunStartIndexAtJump = s.playerAnimFrameIndex;\n      s.playerRunPhaseMsDuringJump = 0;\n      s.playerJumpElapsedMs = 0;\n    }\n  } else {\n    // во время смерти — фиксируем игрока на земле и гасим прыжок\n    s.pendingJump = false;\n    s.player.isJumping = false;\n    s.player.vy = 0;\n    s.player.y = groundY - s.player.height;\n  }\n\n  if (!s.isDying && s.player.isJumping) {\n    s.player.vy += gravityAccel * dtSec;\n    s.player.y += s.player.vy * dtSec;\n    // «немой» прогресс бега во время прыжка\n    s.playerRunPhaseMsDuringJump += dtSec * 1000;\n    s.playerJumpElapsedMs = Math.min(s.playerJumpTotalMs, s.playerJumpElapsedMs + dtSec * 1000);\n    if (s.player.y >= groundY - s.player.height) {\n      s.player.y = groundY - s.player.height;\n      s.player.vy = 0;\n      s.player.isJumping = false;\n      s.playerJumpElapsedMs = s.playerJumpTotalMs;\n      // старт бега с фиксированного кадра run_0\n      if (s.playerRunFrames.length > 0) {\n        s.playerAnimFrameIndex = 0;\n        s.playerAnimElapsedMs = 0;\n      }\n      s.playerRunPhaseMsDuringJump = 0;\n    }\n  }\n}\n\nfunction updateAnimations(s: GameState, dtSec: number): void {\n  // Обновление анимации игрока:\n  // - если игрок умирает — прокручиваем кадры смерти (однократный клип)\n  // - иначе: приоритет reward → hit → run; кадры прыжка выбираются в рендере по времени\n  if (s.playerSprite && s.playerAtlas) {\n    if (s.isDying && s.playerDyingFrames && s.playerDyingFrames.length > 0) {\n      s.playerDyingElapsedMs += dtSec * 1000;\n      while (s.playerDyingElapsedMs >= s.playerAnimFrameMs) {\n        s.playerDyingElapsedMs -= s.playerAnimFrameMs;\n        if (s.playerDyingFrameIndex + 1 < s.playerDyingFrames.length) {\n          s.playerDyingFrameIndex += 1;\n        } else {\n          s.playerDyingPlaying = false;\n          s.playerDyingFrameIndex = s.playerDyingFrames.length - 1;\n          break;\n        }\n      }\n    } else if (s.playerRewardPlaying && s.playerRewardFrames.length > 0) {\n      s.playerRewardElapsedMs += dtSec * 1000;\n      while (s.playerRewardElapsedMs >= s.playerAnimFrameMs) {\n        s.playerRewardElapsedMs -= s.playerAnimFrameMs;\n        if (s.playerRewardFrameIndex + 1 < s.playerRewardFrames.length) {\n          s.playerRewardFrameIndex += 1;\n        } else {\n          s.playerRewardPlaying = false;\n          s.playerRewardFrameIndex = s.playerRewardFrames.length - 1;\n          break;\n        }\n      }\n    } else if (s.playerHitPlaying && s.playerHitFrames.length > 0) {\n      s.playerHitElapsedMs += dtSec * 1000;\n      while (s.playerHitElapsedMs >= s.playerAnimFrameMs) {\n        s.playerHitElapsedMs -= s.playerAnimFrameMs;\n        if (s.playerHitFrameIndex + 1 < s.playerHitFrames.length) {\n          s.playerHitFrameIndex += 1;\n        } else {\n          s.playerHitPlaying = false;\n          s.playerHitFrameIndex = s.playerHitFrames.length - 1;\n          break;\n        }\n      }\n    } else if (s.playerRunFrames.length > 0) {\n      if (s.player.isJumping) {\n        s.playerAnimFrameIndex = 0;\n        s.playerAnimElapsedMs = 0;\n      } else {\n        s.playerAnimElapsedMs += dtSec * 1000;\n        while (s.playerAnimElapsedMs >= s.playerAnimFrameMs) {\n          s.playerAnimElapsedMs -= s.playerAnimFrameMs;\n          s.playerAnimFrameIndex = (s.playerAnimFrameIndex + 1) % s.playerRunFrames.length;\n        }\n      }\n    }\n  }\n\n  // Тик анимации монет (глобальный индекс для всех монет) — во время смерти останавливаем\n  if (!s.isDying && s.coinFrames.length > 0) {\n    s.coinAnimElapsedMs += dtSec * 1000;\n    while (s.coinAnimElapsedMs >= s.playerAnimFrameMs) {\n      s.coinAnimElapsedMs -= s.playerAnimFrameMs;\n      s.coinAnimFrameIndex = (s.coinAnimFrameIndex + 1) % s.coinFrames.length;\n    }\n  }\n  // Тик анимации сердец (глобальный индекс для всех сердец)\n  if (!s.isDying && s.heartFrames.length > 0) {\n    s.heartAnimElapsedMs += dtSec * 1000;\n    while (s.heartAnimElapsedMs >= s.playerAnimFrameMs) {\n      s.heartAnimElapsedMs -= s.playerAnimFrameMs;\n      s.heartAnimFrameIndex = (s.heartAnimFrameIndex + 1) % s.heartFrames.length;\n    }\n  }\n  // Тик анимации скелетов (глобальный индекс для всех скелетов)\n  if (!s.isDying && s.skeletonFrames.length > 0) {\n    s.skeletonAnimElapsedMs += dtSec * 1000;\n    while (s.skeletonAnimElapsedMs >= s.playerAnimFrameMs) {\n      s.skeletonAnimElapsedMs -= s.playerAnimFrameMs;\n      s.skeletonAnimFrameIndex = (s.skeletonAnimFrameIndex + 1) % s.skeletonFrames.length;\n    }\n  }\n  // Тик анимации blight (глобальный индекс для всех объектов этого типа)\n  if (!s.isDying && s.blightFrames.length > 0) {\n    s.blightAnimElapsedMs += dtSec * 1000;\n    while (s.blightAnimElapsedMs >= s.playerAnimFrameMs) {\n      s.blightAnimElapsedMs -= s.playerAnimFrameMs;\n      s.blightAnimFrameIndex = (s.blightAnimFrameIndex + 1) % s.blightFrames.length;\n    }\n  }\n}\n\nfunction spawnObstacles(s: GameState, dtSec: number): void {\n  if (!s.isDying) s.spawnTimerSec += dtSec;\n  if (!s.isDying && s.spawnTimerSec >= s.nextSpawnSec) {\n    const mult = getSpawnIntervalMultiplier(s);\n    // ограниченный рандом: пороги появления сердца\n    const roll = Math.random();\n    let bucket: 'negative' | 'collectible';\n    if (s.sinceLastHeartCount < HEART_MIN_GAP_OBS) {\n      bucket = 'negative';\n    } else if (s.sinceLastHeartCount >= HEART_MAX_GAP_OBS) {\n      bucket = 'collectible';\n    } else {\n      bucket = roll < HEART_BASE_PROB ? 'collectible' : 'negative';\n    }\n\n    if (bucket === 'negative' || s.lifeCount >= 3) {\n      // динамическая доля скелетов: растёт по времени\n      const tNorm = Math.max(0, Math.min(1, s.elapsedSec / SPAWN_CONFIG.scaling.targetSec));\n      const skeletonProb = Math.max(0, Math.min(0.95, SKELETON_IN_NEGATIVE_PROB + 0.35 * tNorm));\n      const isSkeleton = Math.random() < skeletonProb;\n\n      // Глобальное правило честного зазора по времени полёта прыжка\n      const airSec = Math.max(0.1, (s.playerJumpTotalMs || 0) / 1000);\n      const minGapSec = Math.max(SPAWN_CONFIG.scaling.minSafeGapSec, 0.6 * airSec);\n      const minTimeGapCss = Math.max(20, Math.round(speedX * minGapSec));\n      // найдём последнее негативное препятствие\n      let lastNeg: typeof s.entities[number] | null = null;\n      for (let j = s.entities.length - 1; j >= 0; j--) {\n        const e = s.entities[j]!;\n        if (e.kind === 'blight' || e.kind === 'skeleton') {\n          lastNeg = e;\n          break;\n        }\n      }\n      const minHorzGapCss = Math.max(minTimeGapCss, (lastNeg?.width ?? 0) + 12);\n      const spawnX = Math.max(s.cssW, (lastNeg ? lastNeg.x + minHorzGapCss : s.cssW));\n\n      if (isSkeleton) {\n        const cfg = entitiesConfig.skeleton;\n        s.entities.push({\n          x: spawnX,\n          y: groundY - cfg.hitboxH,\n          width: cfg.hitboxW,\n          height: cfg.hitboxH,\n          kind: 'skeleton',\n        });\n      } else {\n        const cfg = entitiesConfig.blight;\n        s.entities.push({\n          x: spawnX,\n          y: groundY - cfg.hitboxH,\n          width: cfg.hitboxW,\n          height: cfg.hitboxH,\n          kind: 'blight',\n        });\n      }\n      s.sinceLastHeartCount += 1;\n\n      // На высокой сложности изредка добавляем «двойной» спавн с малым зазором\n      if (mult <= 0.5 && Math.random() < 0.25) {\n        // последняя вставленная — негативное препятствие; используем динамический безопасный зазор\n        const last = s.entities[s.entities.length - 1];\n        const airSec2 = Math.max(0.1, (s.playerJumpTotalMs || 0) / 1000);\n        const minGapSec2 = Math.max(SPAWN_CONFIG.scaling.minSafeGapSec, 0.6 * airSec2) * 1.2;\n        const minTimeGapCss2 = Math.max(20, Math.round(speedX * minGapSec2));\n        const minHorzGapCss2 = Math.max(minTimeGapCss2, (last?.width ?? 0) + 16);\n        const spawnX2 = (last ? last.x : s.cssW) + minHorzGapCss2;\n\n        // старайтесь не дублировать тип подряд: если рандом совпал — инвертируем\n        let secondIsSkeleton = Math.random() < skeletonProb;\n        if (last && last.kind === 'skeleton' && secondIsSkeleton) secondIsSkeleton = false;\n        if (last && last.kind === 'blight' && !secondIsSkeleton) secondIsSkeleton = true;\n\n        if (secondIsSkeleton) {\n          const cfg = entitiesConfig.skeleton;\n          s.entities.push({\n            x: spawnX2,\n            y: groundY - cfg.hitboxH,\n            width: cfg.hitboxW,\n            height: cfg.hitboxH,\n            kind: 'skeleton',\n          });\n        } else {\n          const cfg = entitiesConfig.blight;\n          s.entities.push({\n            x: spawnX2,\n            y: groundY - cfg.hitboxH,\n            width: cfg.hitboxW,\n            height: cfg.hitboxH,\n            kind: 'blight',\n          });\n        }\n      }\n    } else {\n      // collectible здесь — только сердце\n      const cfg = entitiesConfig.heart;\n      s.entities.push({\n        x: s.cssW,\n        y: groundY - cfg.hitboxH,\n        width: cfg.hitboxW,\n        height: cfg.hitboxH,\n        kind: 'heart',\n      });\n      s.sinceLastHeartCount = 0;\n    }\n    s.spawnTimerSec = 0;\n    const sc = SPAWN_CONFIG.scaling;\n    const minI = SPAWN_INTERVAL_MIN_SEC * mult;\n    const maxI = SPAWN_INTERVAL_MAX_SEC * mult;\n    const baseNext = minI + Math.random() * Math.max(0, maxI - minI);\n    let next = Math.max(sc.minSafeGapSec, baseNext);\n    // «Окно отдыха» — реже, на высокой сложности\n    const r = sc.rest;\n    if (s.restCooldownSec <= 0 && mult <= r.whenMultiplierLE && Math.random() < r.probability) {\n      const restGap = Math.max(sc.minSafeGapSec, sc.minSafeGapSec * r.gapMultiplier);\n      next = Math.max(next, restGap);\n      s.restCooldownSec = r.cooldownSec;\n    }\n    s.nextSpawnSec = next;\n  }\n}\n\nfunction spawnCoins(s: GameState, dtSec: number): void {\n  // Независимый спавн монет (может совпадать по X/Y с другими объектами) — на паузе во время смерти\n  if (!s.isDying) s.coinSpawnTimerSec += dtSec;\n  if (!s.isDying && s.coinNextSpawnSec <= 0) {\n    s.coinNextSpawnSec =\n      COIN_SPAWN_INTERVAL_MIN_SEC +\n      Math.random() * (COIN_SPAWN_INTERVAL_MAX_SEC - COIN_SPAWN_INTERVAL_MIN_SEC);\n  }\n  if (!s.isDying && s.coinSpawnTimerSec >= s.coinNextSpawnSec) {\n    const cfg = entitiesConfig.coin;\n    const coinH = cfg.hitboxH;\n    const apex = (jumpVelocity * jumpVelocity) / (2 * Math.abs(gravityAccel)); // высота вершины прыжка\n    const bottomY = Math.max(0, groundY - apex);\n    const y = Math.max(0, bottomY - coinH);\n    s.entities.push({ x: s.cssW, y, width: cfg.hitboxW, height: coinH, kind: 'coin' });\n    s.coinSpawnTimerSec = 0;\n    s.coinNextSpawnSec =\n      COIN_SPAWN_INTERVAL_MIN_SEC +\n      Math.random() * (COIN_SPAWN_INTERVAL_MAX_SEC - COIN_SPAWN_INTERVAL_MIN_SEC);\n  }\n}\n\nfunction updateEntitiesAndCollisions(s: GameState, dtSec: number): void {\n  if (s.isDying) return;\n\n  for (let i = s.entities.length - 1; i >= 0; i--) {\n    const obs = s.entities[i]!;\n    obs.x -= speedX * dtSec;\n    if (obs.x + obs.width < 0) {\n      s.entities.splice(i, 1);\n      continue;\n    }\n    if (\n      obs.x < s.player.x + s.player.width &&\n      obs.x + obs.width > s.player.x &&\n      obs.y < s.player.y + s.player.height &&\n      obs.y + obs.height > s.player.y\n    ) {\n      if (s.isDying) {\n        // Во время анимации смерти игнорируем любые новые столкновения\n        continue;\n      }\n      // Обработка столкновения в зависимости от типа сущности\n      if (obs.kind === 'heart' || obs.kind === 'coin') {\n        s.entities.splice(i, 1);\n        // Счётчики собираемых объектов\n        if (obs.kind === 'coin') {\n          s.coinCount += 1;\n          s.uiDirty = true;\n        } else if (obs.kind === 'heart') {\n          if (s.lifeCount < 3) {\n            s.lifeCount += 1;\n            s.uiDirty = true;\n          }\n        }\n        // SFX для сбора предметов\n        if (obs.kind === 'coin') {\n          try {\n            postMessage({ type: 'sfx', s: 'coin' } as WorkerOutMessage);\n          } catch {\n            // игнорируем ошибки отправки звука монеты\n          }\n        } else if (obs.kind === 'heart') {\n          try {\n            postMessage({ type: 'sfx', s: 'heart' } as WorkerOutMessage);\n          } catch {\n            // игнорируем ошибки отправки звука сердца\n          }\n        }\n        // Однократная анимация «награды» при сборе\n        if (s.playerRewardFrames.length > 0) {\n          s.playerRewardPlaying = true;\n          s.playerRewardElapsedMs = 0;\n          s.playerRewardFrameIndex = 0;\n        }\n      } else {\n        s.entities.splice(i, 1);\n        // Столкновение с препятствием уменьшает число жизней (но не ниже нуля)\n        if (s.lifeCount > 0) {\n          s.lifeCount -= 1;\n          s.uiDirty = true;\n        }\n        // Сбрасываем стрик и включаем «релакс»-кулдаун\n        s.noHitSec = 0;\n        s.recentHitCooldownSec = Math.max(\n          s.recentHitCooldownSec,\n          SPAWN_CONFIG.scaling.relax.recentHitSecs,\n        );\n        // SFX для столкновений с препятствиями (для текущего удара)\n        if (obs.kind === 'blight') {\n          try {\n            postMessage({ type: 'sfx', s: 'blight' } as WorkerOutMessage);\n          } catch {\n            // игнорируем ошибки отправки звука blight\n          }\n        } else if (obs.kind === 'skeleton') {\n          try {\n            postMessage({ type: 'sfx', s: 'skeleton' } as WorkerOutMessage);\n          } catch {\n            // игнорируем ошибки отправки звука skeleton\n          }\n        }\n        // Если жизни закончились — запускаем состояние смерти (анимация + задержка до gameover)\n        if (s.lifeCount <= 0 && !s.isDying) {\n          s.isDying = true;\n          s.dyingElapsedMs = 0;\n          s.gameOverSent = false;\n          s.pendingJump = false;\n          s.player.isJumping = false;\n          s.player.vy = 0;\n          s.player.y = groundY - s.player.height;\n          s.playerHitPlaying = false;\n          s.playerRewardPlaying = false;\n          try {\n            postMessage({ type: 'death' } as WorkerOutMessage);\n          } catch {\n            // игнорируем ошибки отправки события смерти\n          }\n          if (s.playerDyingFrames.length > 0) {\n            s.playerDyingPlaying = true;\n            s.playerDyingElapsedMs = 0;\n            s.playerDyingFrameIndex = 0;\n          }\n        } else {\n          // Однократная анимация «удара», если игрок ещё не умер\n          if (s.playerHitFrames.length > 0) {\n            s.playerHitPlaying = true;\n            s.playerHitElapsedMs = 0;\n            s.playerHitFrameIndex = 0;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction updateDeathTimer(s: GameState, dtSec: number): void {\n  // Завершение: отправляем gameover спустя dyingDurationMs после начала смерти\n  if (s.isDying) {\n    s.dyingElapsedMs += dtSec * 1000;\n    if (!s.gameOverSent && s.dyingElapsedMs >= s.dyingDurationMs) {\n      s.gameOverSent = true;\n      try {\n        postMessage({ type: 'gameover' } as WorkerOutMessage);\n      } catch {\n        // игнорируем ошибки отправки gameover\n      }\n    }\n  }\n}\n\nexport function update(s: GameState, dtSec: number): void {\n  if (!s.ctx) return;\n\n  // Сохраняем позицию игрока с предыдущего шага для интерполяции в рендере\n  s.prevPlayerY = s.player.y;\n\n  updateDifficultyTimers(s, dtSec);\n  updatePlayerJumpState(s, dtSec);\n  updateAnimations(s, dtSec);\n  spawnObstacles(s, dtSec);\n  spawnCoins(s, dtSec);\n  updateEntitiesAndCollisions(s, dtSec);\n  updateDeathTimer(s, dtSec);\n}\n","import type { AtlasFrame, GameState, PlayerAtlas } from './state';\n\nexport async function ensurePlayerSprite(s: GameState): Promise<void> {\n  if (!s.ctx) return;\n  if (s.playerSprite || s.playerAtlas || s.playerSpriteLoading) return;\n  if (!s.playerSpriteUrl || !s.playerAtlasUrl) return;\n  s.playerSpriteLoading = true;\n  try {\n    const [imgRes, jsonRes] = await Promise.all([fetch(s.playerSpriteUrl), fetch(s.playerAtlasUrl)]);\n    if (!imgRes.ok) throw new Error('Failed to fetch player sprite');\n    if (!jsonRes.ok) throw new Error('Failed to fetch player atlas');\n    const [imgBlob, atlas]: [Blob, PlayerAtlas] = [await imgRes.blob(), (await jsonRes.json()) as PlayerAtlas];\n    const bmp = await createImageBitmap(imgBlob);\n    // Подготовим порядок кадров по X\n    type NamedFrameEntry = [string, AtlasFrame];\n    const byX = (a: NamedFrameEntry, b: NamedFrameEntry): number => {\n      const ax = a[1].frame.x ?? 0;\n      const bx = b[1].frame.x ?? 0;\n      if (ax !== bx) return ax - bx;\n      const ai = parseInt(a[0].split('_')[1] || '0', 10);\n      const bi = parseInt(b[0].split('_')[1] || '0', 10);\n      return ai - bi;\n    };\n\n    const frames = atlas.frames || {};\n    const frameEntries = Object.entries(frames) as NamedFrameEntry[];\n    const runEntries = frameEntries.filter(([k]) => k.startsWith('run_')).sort(byX);\n    const jumpEntries = frameEntries.filter(([k]) => k.startsWith('jump_')).sort(byX);\n    const hitEntries = frameEntries.filter(([k]) => k.startsWith('hit_')).sort(byX);\n    const dyingEntries = frameEntries.filter(([k]) => k.startsWith('dying_')).sort(byX);\n    const blightEntries = frameEntries.filter(([k]) => k.startsWith('blight_')).sort(byX);\n    const heartEntries = frameEntries.filter(([k]) => k.startsWith('heart_')).sort(byX);\n    const coinEntries = frameEntries.filter(([k]) => k.startsWith('coin_')).sort(byX);\n    const skeletonEntries = frameEntries.filter(([k]) => k.startsWith('skeleton_')).sort(byX);\n\n    // Приоритет animations из JSON\n    const pickValid = (names?: string[]) =>\n      (names || []).filter((n) => !!frames[n]);\n\n    const anims = atlas.animations || {};\n    let runNames = pickValid(anims.run);\n    let jumpNames = pickValid(anims.jump);\n    let hitNames = pickValid(anims.hit);\n    let rewardNames = pickValid(anims.reward);\n    let dyingNames = pickValid(anims.dying);\n    let blightNames = pickValid(anims.blight);\n    let heartNames = pickValid(anims.heart);\n    let coinName = pickValid(anims.coin)?.[0];\n    let coinNames = pickValid(anims.coin);\n    let skeletonNames = pickValid(anims.skeleton);\n\n    if (!runNames || runNames.length === 0) runNames = runEntries.map(([k]) => k);\n    if (!jumpNames || jumpNames.length === 0) jumpNames = jumpEntries.map(([k]) => k);\n    if (!hitNames || hitNames.length === 0) hitNames = hitEntries.map(([k]) => k);\n    if (!rewardNames || rewardNames.length === 0) rewardNames = Object.keys(frames).filter((k) => k.startsWith('reward_')).sort().map((k) => k);\n    if (!dyingNames || dyingNames.length === 0) dyingNames = dyingEntries.map(([k]) => k);\n    if (!blightNames || blightNames.length === 0) blightNames = blightEntries.map(([k]) => k);\n    if (!heartNames || heartNames.length === 0) heartNames = heartEntries.map(([k]) => k);\n    if (!coinName) coinName = coinEntries[0]?.[0];\n    if (!coinNames || coinNames.length === 0) coinNames = coinEntries.map(([k]) => k);\n    if (!skeletonNames || skeletonNames.length === 0) skeletonNames = skeletonEntries.map(([k]) => k);\n\n    s.playerRunFrames = runNames;\n    s.playerJumpFrames = jumpNames;\n    s.playerHitFrames = hitNames;\n    s.playerRewardFrames = rewardNames;\n    s.playerDyingFrames = dyingNames;\n    s.blightFrames = blightNames || [];\n    s.heartFrames = heartNames || [];\n    s.coinFrameName = coinName ?? null;\n    s.coinFrames = coinNames || [];\n    s.skeletonFrames = skeletonNames || [];\n    s.playerSprite = bmp;\n    s.playerAtlas = atlas;\n  } finally {\n    s.playerSpriteLoading = false;\n  }\n}\n","import { playerConfig, entitiesConfig, GROUND_BOTTOM_MARGIN_CSS } from '@/config/visual';\n\nimport type { GameState } from './state';\nimport { groundY, speedX } from './constants';\nimport { ensurePlayerSprite } from './assets';\n\nexport function draw(s: GameState, alpha: number = 1, stepSec: number = 1 / 60): void {\n  if (!s.ctx || !s.canvas) return;\n\n  // Очистка буфера\n  if (s.transparentBg) {\n    s.ctx.clearRect(0, 0, s.canvas.width, s.canvas.height);\n  } else {\n    s.ctx.fillStyle = s.skyColor;\n    s.ctx.fillRect(0, 0, s.canvas.width, s.canvas.height);\n  }\n\n  // Фиксируем линию земли на GROUND_BOTTOM_MARGIN_CSS от низа холста:\n  // вычисляем вертикальное смещение так, чтобы верх земли (groundY) попадал в cssH - GROUND_BOTTOM_MARGIN_CSS\n  const groundTopCss = s.cssH - GROUND_BOTTOM_MARGIN_CSS;\n  const offsetYpx = Math.round((groundTopCss - groundY) * s.scale);\n\n  // Рисуем игрока\n  const playerYInterp = s.prevPlayerY + (s.player.y - s.prevPlayerY) * alpha;\n  void ensurePlayerSprite(s);\n  if (s.playerSprite && s.playerAtlas) {\n    // Выбор кадра по приоритету: dying → reward → hit → jump → run\n    let chosenName: string | null = null;\n    if (s.isDying && s.playerDyingFrames && s.playerDyingFrames.length > 0) {\n      chosenName = s.playerDyingFrames[Math.max(0, Math.min(s.playerDyingFrames.length - 1, s.playerDyingFrameIndex))] || null;\n    } else if (s.playerRewardPlaying && s.playerRewardFrames.length > 0) {\n      chosenName = s.playerRewardFrames[Math.max(0, Math.min(s.playerRewardFrames.length - 1, s.playerRewardFrameIndex))] || null;\n    } else if (s.playerHitPlaying && s.playerHitFrames.length > 0) {\n      chosenName = s.playerHitFrames[Math.max(0, Math.min(s.playerHitFrames.length - 1, s.playerHitFrameIndex))] || null;\n    } else if (s.player.isJumping && s.playerJumpFrames.length > 0) {\n      // В начале прыжка коротко показываем кадр бега, с которого стартовали\n      const total = s.playerJumpTotalMs || 1;\n      const pRaw = Math.max(0, Math.min(1, s.playerJumpElapsedMs / total));\n      const holdStart = 0.1; // 10% времени прыжка — стартовый кадр бега\n      if (pRaw < holdStart && s.playerRunFrames.length > 0) {\n        chosenName = s.playerRunFrames[Math.max(0, Math.min(s.playerRunFrames.length - 1, s.playerRunStartIndexAtJump))];\n      } else {\n        // Равномерное распределение кадров по оставшемуся времени прыжка\n        const p = Math.max(0, Math.min(1, (pRaw - holdStart) / (1 - holdStart)));\n        const n = s.playerJumpFrames.length;\n        const idx = Math.max(0, Math.min(n - 1, Math.floor(p * (n - 1) + 1e-6)));\n        chosenName = s.playerJumpFrames[idx];\n      }\n    } else if (s.playerRunFrames.length > 0) {\n      chosenName = s.playerRunFrames[Math.max(0, Math.min(s.playerRunFrames.length - 1, s.playerAnimFrameIndex))];\n    }\n\n    const frFull = chosenName ? s.playerAtlas.frames[chosenName] : undefined;\n    const fr = frFull?.frame;\n    const pivot = frFull?.pivot || { x: 0.5, y: 1 };\n    if (fr) {\n      const destHcss = playerConfig.visualHeight;\n      const destWcss = (fr.w / fr.h) * destHcss;\n      const leftCss = s.player.x - pivot.x * destWcss + (playerConfig.offsetX || 0);\n      const bottomCss = playerYInterp + s.player.height + (playerConfig.offsetY || 0);\n      const topCss = bottomCss - destHcss * pivot.y;\n      const dx = Math.round(leftCss * s.scale);\n      const dy = Math.round((topCss) * s.scale + offsetYpx);\n      const dw = Math.max(1, Math.round(destWcss * s.scale));\n      const dh = Math.max(1, Math.round(destHcss * s.scale));\n      const prevSmooth = s.ctx.imageSmoothingEnabled;\n      s.ctx.imageSmoothingEnabled = false;\n      s.ctx.drawImage(\n        s.playerSprite,\n        fr.x, fr.y, fr.w, fr.h,\n        dx, dy, dw, dh\n      );\n      s.ctx.imageSmoothingEnabled = prevSmooth;\n    }\n  } else {\n    s.ctx.fillStyle = '#000';\n    s.ctx.fillRect(\n      Math.round(s.player.x * s.scale),\n      Math.round(playerYInterp * s.scale + offsetYpx),\n      Math.round(s.player.width * s.scale),\n      Math.round(s.player.height * s.scale)\n    );\n  }\n  // Отладочный оверлей хитбокса игрока\n  if (s.debugDrawHitboxes) {\n    const dx = Math.round(s.player.x * s.scale);\n    const dy = Math.round(playerYInterp * s.scale + offsetYpx);\n    const dw = Math.round(s.player.width * s.scale);\n    const dh = Math.round(s.player.height * s.scale);\n    s.ctx.save();\n    s.ctx.globalAlpha = 0.3;\n    s.ctx.fillStyle = '#ff00ff';\n    s.ctx.fillRect(dx, dy, dw, dh);\n    s.ctx.globalAlpha = 1;\n    s.ctx.lineWidth = Math.max(1, Math.round(s.scale));\n    s.ctx.strokeStyle = '#ff00ff';\n    s.ctx.strokeRect(dx, dy, dw, dh);\n    s.ctx.restore();\n  }\n\n  // Сущности (не рисуем во время анимации смерти игрока)\n  if (!s.isDying) for (const obs of s.entities) {\n    const obsXInterp = obs.x + speedX * stepSec * (1 - alpha);\n    const dxCss = obsXInterp;\n    const dyCss = obs.y;\n    // Если есть атласные спрайты — рисуем по атласу, иначе — fallback-прямоугольник\n    if (s.playerSprite && s.playerAtlas && (obs.kind === 'blight' || obs.kind === 'skeleton' || obs.kind === 'heart' || obs.kind === 'coin')) {\n      const name =\n        obs.kind === 'blight'\n          ? (s.blightFrames.length > 0\n              ? s.blightFrames[Math.max(0, Math.min(s.blightFrames.length - 1, s.blightAnimFrameIndex))]\n              : null)\n          : (obs.kind === 'skeleton'\n              ? (s.skeletonFrames.length > 0\n                  ? s.skeletonFrames[Math.max(0, Math.min(s.skeletonFrames.length - 1, s.skeletonAnimFrameIndex))]\n                  : null)\n            : (obs.kind === 'heart'\n                ? (s.heartFrames.length > 0\n                    ? s.heartFrames[Math.max(0, Math.min(s.heartFrames.length - 1, s.heartAnimFrameIndex))]\n                    : null)\n                  : (s.coinFrames.length > 0\n                      ? s.coinFrames[Math.max(0, Math.min(s.coinFrames.length - 1, s.coinAnimFrameIndex))]\n                      : s.coinFrameName)));\n      const frFull = name ? s.playerAtlas.frames[name] : undefined;\n      const fr = frFull?.frame;\n      const pivot = frFull?.pivot || { x: 0.5, y: 1 };\n      if (fr) {\n        const cfg = entitiesConfig[obs.kind];\n        const destHcss = cfg.visualHeight;\n        const destWcss = (fr.w / fr.h) * destHcss;\n        const leftCss = dxCss - pivot.x * destWcss + obs.width * 0.5 + (cfg.offsetX || 0); // центрируем по хитбоксу\n        const bottomCss = dyCss + obs.height + (cfg.offsetY || 0);\n        const topCss = bottomCss - destHcss * pivot.y;\n        const dx = Math.round(leftCss * s.scale);\n        const dy = Math.round((topCss) * s.scale + offsetYpx);\n        const dw = Math.max(1, Math.round(destWcss * s.scale));\n        const dh = Math.max(1, Math.round(destHcss * s.scale));\n        const prevSmooth = s.ctx.imageSmoothingEnabled;\n        s.ctx.imageSmoothingEnabled = false;\n        s.ctx.drawImage(\n          s.playerSprite,\n          fr.x, fr.y, fr.w, fr.h,\n          dx, dy, dw, dh\n        );\n        s.ctx.imageSmoothingEnabled = prevSmooth;\n        // Отладочный оверлей хитбокса сущности (ветка отрисовки по атласу)\n        if (s.debugDrawHitboxes) {\n          const hbDx = Math.round(dxCss * s.scale);\n          const hbDy = Math.round(dyCss * s.scale + offsetYpx);\n          const hbDw = Math.round(obs.width * s.scale);\n          const hbDh = Math.round(obs.height * s.scale);\n          s.ctx.save();\n          s.ctx.globalAlpha = 0.3;\n          s.ctx.fillStyle = '#ff00ff';\n          s.ctx.fillRect(hbDx, hbDy, hbDw, hbDh);\n          s.ctx.globalAlpha = 1;\n          s.ctx.lineWidth = Math.max(1, Math.round(s.scale));\n          s.ctx.strokeStyle = '#ff00ff';\n          s.ctx.strokeRect(hbDx, hbDy, hbDw, hbDh);\n          s.ctx.restore();\n        }\n        continue;\n      }\n    }\n    // Fallback-прямоугольник, если спрайт не найден\n    s.ctx.fillStyle = obs.kind === 'heart' ? '#0a0' : (obs.kind === 'coin' ? '#fc0' : 'red');\n    s.ctx.fillRect(\n      Math.round(dxCss * s.scale),\n      Math.round(dyCss * s.scale + offsetYpx),\n      Math.round(obs.width * s.scale),\n      Math.round(obs.height * s.scale)\n    );\n\n    // Отладочный оверлей хитбокса сущности\n    if (s.debugDrawHitboxes) {\n      const dx = Math.round(dxCss * s.scale);\n      const dy = Math.round(dyCss * s.scale + offsetYpx);\n      const dw = Math.round(obs.width * s.scale);\n      const dh = Math.round(obs.height * s.scale);\n      s.ctx.save();\n      s.ctx.globalAlpha = 0.3;\n      s.ctx.fillStyle = '#ff00ff';\n      s.ctx.fillRect(dx, dy, dw, dh);\n      s.ctx.globalAlpha = 1;\n      s.ctx.lineWidth = Math.max(1, Math.round(s.scale));\n      s.ctx.strokeStyle = '#ff00ff';\n      s.ctx.strokeRect(dx, dy, dw, dh);\n      s.ctx.restore();\n    }\n  }\n}\n","// Точка входа воркера рендера/логики (OffscreenCanvas)\nimport type { WorkerInMessage, WorkerOutMessage } from '@/types/workerMessages';\n\nimport { state, applyCanvasSize, resetGameStateRuntime } from './worker/state';\nimport { update } from './worker/logic';\nimport { draw } from './worker/render';\n\nfunction markReady() {\n  if (state.ready) return;\n  state.ready = true;\n  postMessage({ type: 'ready' } as WorkerOutMessage);\n}\n\n// Тайминг-цикл: главный поток даёт rAF, воркер считает фиксированным шагом\nlet lastNow = 0;\nlet accMs = 0;\nconst FIXED_DT_MS = 1000 / 60;\nconst MAX_FRAME_DT_MS = 100; // ограничиваем скачки dt, чтобы не было огромного «догоняющего» шага\nconst MAX_CATCHUP_STEPS = 5; // ограничиваем количество catch-up шагов, чтобы не уйти в «спираль смерти»\n\nfunction frame(now: number) {\n  if (!state.ready) return; // ждём handshake из init/resize\n  if (!lastNow) lastNow = now;\n  let dtMs = now - lastNow;\n  lastNow = now;\n  if (dtMs < 0) dtMs = 0;\n  if (dtMs > MAX_FRAME_DT_MS) dtMs = MAX_FRAME_DT_MS;\n\n  // Симуляция с фиксированным шагом\n  accMs += dtMs;\n  let steps = 0;\n  while (accMs >= FIXED_DT_MS && steps < MAX_CATCHUP_STEPS) {\n    update(state, FIXED_DT_MS / 1000);\n    accMs -= FIXED_DT_MS;\n    steps++;\n  }\n\n  state.uiElapsedMs += dtMs;\n  if (state.uiDirty && state.uiElapsedMs >= state.uiIntervalMs) {\n    postMessage({ type: 'ui', coinCount: state.coinCount, lifeCount: state.lifeCount } as WorkerOutMessage);\n    state.uiDirty = false; state.uiElapsedMs = 0;\n  }\n\n  // Рисуем на каждый тик rAF из главного потока\n  const alpha = Math.max(0, Math.min(1, accMs / FIXED_DT_MS));\n  draw(state, alpha, FIXED_DT_MS / 1000);\n}\n\nonmessage = (ev: MessageEvent<WorkerInMessage>) => {\n  const data = ev.data || ({} as WorkerInMessage);\n  switch (data.type) {\n    case 'init': {\n      state.canvas = data.canvas;\n      state.skyColor = typeof data.skyColor === 'string' ? data.skyColor : state.skyColor;\n      state.expectResize = !!data.expectResize;\n      state.debugDrawHitboxes = Boolean(data.debugHitboxes);\n\n      const wantAlpha = Boolean(data.alpha);\n      state.ctx = state.canvas.getContext('2d', { alpha: wantAlpha });\n      if (!state.ctx) return;\n      state.ctx.imageSmoothingEnabled = false;\n\n      state.transparentBg = Boolean(data.transparentBg);\n\n      applyCanvasSize(state, data.cssW, data.cssH, data.dpr);\n\n      if (state.expectResize) {\n        if (state.readyTimer) clearTimeout(state.readyTimer);\n        state.readyTimer = setTimeout(() => { markReady(); }, 200) as unknown as number;\n      } else {\n        markReady();\n      }\n      break;\n    }\n    case 'resize': {\n      applyCanvasSize(state, data.cssW, data.cssH, data.dpr);\n      if (state.expectResize) {\n        state.expectResize = false;\n        if (state.readyTimer) { clearTimeout(state.readyTimer); state.readyTimer = null; }\n        markReady();\n      }\n      break;\n    }\n    case 'frame': {\n      frame(typeof data.now === 'number' ? data.now : performance.now());\n      break;\n    }\n    case 'vis': {\n      // сброс тайминга при смене видимости, чтобы избежать рывка\n      lastNow = 0;\n      accMs = 0;\n      break;\n    }\n    case 'reset': {\n      // Мягкий рестарт: сбрасываем игровое состояние и таймеры симуляции\n      resetGameStateRuntime(state);\n      lastNow = 0;\n      accMs = 0;\n      // сразу отправим обновление UI с нулевым счётом и полными жизнями\n      postMessage(\n        {\n          type: 'ui',\n          coinCount: state.coinCount,\n          lifeCount: state.lifeCount,\n        } as WorkerOutMessage,\n      );\n      break;\n    }\n    case 'input': {\n      if (data.tap || data.space) {\n        // Принимаем прыжок только если игрок на земле и не в состоянии смерти\n        if (!state.isDying && state.lifeCount > 0 && !state.player.isJumping) {\n          state.pendingJump = true;\n        }\n      }\n      break;\n    }\n  }\n};\n"],"names":["playerConfig","entitiesConfig","GROUND_BOTTOM_MARGIN_CSS","groundY","speedX","gravityAccel","jumpVelocity","SPAWN_CONFIG","SPAWN_INTERVAL_MIN_SEC","SPAWN_INTERVAL_MAX_SEC","HEART_BASE_PROB","HEART_MIN_GAP_OBS","HEART_MAX_GAP_OBS","SKELETON_IN_NEGATIVE_PROB","COIN_SPAWN_INTERVAL_MIN_SEC","COIN_SPAWN_INTERVAL_MAX_SEC","MAX_W_PX","MAX_H_PX","playerSpriteUrlObj","playerAtlasUrlObj","state","resetGameStateRuntime","s","applyCanvasSize","newCssW","newCssH","dpr","rawDpr","areaCss","maxAreaPx","dprByCaps","perfCap","dprClamped","x","sW","sH","bound","uniform","targetWpx","targetHpx","easeInOutQuad","t","getSpawnIntervalMultiplier","sc","tNorm","mTime","mCoin","mStreak","m","updateDifficultyTimers","dtSec","updatePlayerJumpState","updateAnimations","spawnObstacles","mult","roll","bucket","skeletonProb","isSkeleton","airSec","minGapSec","minTimeGapCss","lastNeg","j","e","minHorzGapCss","spawnX","cfg","last","airSec2","minGapSec2","minTimeGapCss2","minHorzGapCss2","spawnX2","secondIsSkeleton","minI","maxI","baseNext","next","r","restGap","spawnCoins","coinH","apex","bottomY","y","updateEntitiesAndCollisions","i","obs","updateDeathTimer","update","ensurePlayerSprite","imgRes","jsonRes","imgBlob","atlas","bmp","byX","a","b","ax","bx","ai","bi","frames","frameEntries","runEntries","k","jumpEntries","hitEntries","dyingEntries","blightEntries","heartEntries","coinEntries","skeletonEntries","pickValid","names","n","anims","runNames","jumpNames","hitNames","rewardNames","dyingNames","blightNames","heartNames","coinName","coinNames","skeletonNames","draw","alpha","stepSec","groundTopCss","offsetYpx","playerYInterp","chosenName","total","pRaw","holdStart","p","idx","frFull","fr","pivot","destHcss","destWcss","leftCss","topCss","dx","dy","dw","dh","prevSmooth","dxCss","dyCss","name","hbDx","hbDy","hbDw","hbDh","markReady","lastNow","accMs","FIXED_DT_MS","MAX_FRAME_DT_MS","MAX_CATCHUP_STEPS","frame","now","dtMs","steps","ev","data","wantAlpha"],"mappings":"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"}